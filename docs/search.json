[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Analysing Genomic Data with dartRverse",
    "section": "",
    "text": "Welcome!\nWelcome to the second dartR workshop hosted at Kioloa ~ Kioloa2!\nWelcome, Fellow Magical Beings, to our 5-day spellbinding journey in the mystical realm of Population Genetics using the ancient art of R! We’re over the moon (and not just because we’ve mastered levitation spells) to have you join us at the enchanted Kioloa ANU Coastal Campus. Nestled among the spellbound forests of Murramarang Nation Park and the crystal-clear waters of southern New South Wales, our meeting lair couldn’t be more perfect. When you’re not weaving R spells, you’ll find yourself spoiled for choice with magical brews (a.k.a. coffee) and breathtaking sceneries.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#a-big-thank-you-to-the-developers",
    "href": "index.html#a-big-thank-you-to-the-developers",
    "title": "Analysing Genomic Data with dartRverse",
    "section": "A big thank you to the developers!",
    "text": "A big thank you to the developers!\nDartR published first by Gruber et al. (2018), and DartR V2 published by Mijangos et al. (2022)",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "Program",
    "section": "",
    "text": "for a more detailed program see the More Info section\n\n\n\n\n\n\n\n\n\n\n#\nDay\nTime\nTopic\nPresenters\n\n\n\n\n1\nMon\n2 pm - 4 pm\nWelcome, Intro dartR\nOliver Berry, Andrzej Killian, Arthur Georges, Bernd Gruber, Renee Catullo\n\n\n2\n\n5 pm – 7 pm\nPop Gen In Conservation & Restoration\nBill Sherwin, Carlo Pacioni, Renee Catullo\n\n\n3\nTue\n9 am – 11 am\nSequencing Technologies\nJason Carling, Andrew Kowalczyk, Renee Catullo\n\n\n4\n\n12 pm – 2 pm\nData Management, Reproducibility & Integrity\nJiajia Li\n\n\n5\n\n3 pm – 5 pm\nEffective Population Size\nBernd Gruber, Carlo Pacioni, Bill Sherwin\n\n\n6\nWed\n9 am – 11 am\nManagement Of Small Populations\nCatherine Grueber, Kate Farquharson\n\n\n7\n\n12 pm – 2 pm\nNatural Selection\nLuciano Beheregaray, Chris Brauer, Jonathan Sandoval\n\n\n8\n\n3 pm – 5 pm\nLandscape Genetics\nBernd Gruber, Robyn Shaw\n\n\n9\nThu\n9 am – 11 am\nLineage Divergence\nArthur Georges, Sally Potter, Craig Moritz\n\n\n10\n\n12 pm – 2 pm\nSex Linked Markers\nDiana Robledo, Floriaan Devloo-Delva\n\n\n11\n\n7 pm – 9 pm\nFrom Genes to Kin: Dissecting Relatedness & Kinship\nJinliang Wang, Luis Mijangos, Natasha Marosi\n\n\n12\nFri\n9 am – 11 am\nGenetic Structure\nArthur Georges, Bernd Gruber, Bill Sherwin\n\n\n13\n\n12 pm – 2 pm\nCombining Genomic Resources\nLuis Mijangos, Sally Potter",
    "crumbs": [
      "Program"
    ]
  },
  {
    "objectID": "inst/tutorials/W01/W01.html",
    "href": "inst/tutorials/W01/W01.html",
    "title": "1  W01 Pop Gen in Conservation and Restoration",
    "section": "",
    "text": "W01 Pop Gen in Conservation and Restoration",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>W01 Pop Gen in Conservation and Restoration</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W01/W01.html#introduction",
    "href": "inst/tutorials/W01/W01.html#introduction",
    "title": "1  W01 Pop Gen in Conservation and Restoration",
    "section": "Introduction",
    "text": "Introduction\n\nLearning outcomes\nWhat is the goal of this session? What will participants learn?\n\n\nPrerquisites\nWhat prior knowledge do they need?\n\n\nWorkflow\nWhat is the structure of the session?\n\n\nAdditional reading\nAnything else you want to add?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>W01 Pop Gen in Conservation and Restoration</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W01/W01.html#topic",
    "href": "inst/tutorials/W01/W01.html#topic",
    "title": "1  W01 Pop Gen in Conservation and Restoration",
    "section": "Topic",
    "text": "Topic\nBrief recap of the topic, relating back to the presentation.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>W01 Pop Gen in Conservation and Restoration</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W01/W01.html#worked-ex",
    "href": "inst/tutorials/W01/W01.html#worked-ex",
    "title": "1  W01 Pop Gen in Conservation and Restoration",
    "section": "Worked Ex:",
    "text": "Worked Ex:\nWorked example that everyone steps through together - simple example applying the methods\n\n# We show them the code to run",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>W01 Pop Gen in Conservation and Restoration</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W01/W01.html#exercises",
    "href": "inst/tutorials/W01/W01.html#exercises",
    "title": "1  W01 Pop Gen in Conservation and Restoration",
    "section": "Exercises",
    "text": "Exercises\nExercises where they can use their own data or supplied data to try out what they have learnt in a new context.\n\ndot points\nfor different steps",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>W01 Pop Gen in Conservation and Restoration</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W01/W01.html#winding-up",
    "href": "inst/tutorials/W01/W01.html#winding-up",
    "title": "1  W01 Pop Gen in Conservation and Restoration",
    "section": "Winding up",
    "text": "Winding up\n\nDiscussion Time\nAdd some questions to help group discussion.\n\n\nWhere have we come?\nSummarise what they should have learnt.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>W01 Pop Gen in Conservation and Restoration</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W02/W02.html",
    "href": "inst/tutorials/W02/W02.html",
    "title": "2  W02 dartR Intro",
    "section": "",
    "text": "W02 dartR Intro, Data Manipulation & Filtering",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>W02 dartR Intro</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W02/W02.html#introduction",
    "href": "inst/tutorials/W02/W02.html#introduction",
    "title": "2  W02 dartR Intro",
    "section": "Introduction",
    "text": "Introduction\n\nLearning outcomes\nWhat is the goal of this session? What will participants learn?\n\n\nPrerquisites\nWhat prior knowledge do they need?\n\n\nWorkflow\nWhat is the structure of the session?\n\n\nAdditional reading\nAnything else you want to add?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>W02 dartR Intro</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W02/W02.html#topic",
    "href": "inst/tutorials/W02/W02.html#topic",
    "title": "2  W02 dartR Intro",
    "section": "Topic",
    "text": "Topic\nBrief recap of the topic, relating back to the presentation.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>W02 dartR Intro</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W02/W02.html#worked-ex",
    "href": "inst/tutorials/W02/W02.html#worked-ex",
    "title": "2  W02 dartR Intro",
    "section": "Worked Ex:",
    "text": "Worked Ex:\nWorked example that everyone steps through together - simple example applying the methods\n\n# We show them the code to run",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>W02 dartR Intro</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W02/W02.html#exercises",
    "href": "inst/tutorials/W02/W02.html#exercises",
    "title": "2  W02 dartR Intro",
    "section": "Exercises",
    "text": "Exercises\nExercises where they can use their own data or supplied data to try out what they have learnt in a new context.\n\ndot points\nfor different steps",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>W02 dartR Intro</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W02/W02.html#winding-up",
    "href": "inst/tutorials/W02/W02.html#winding-up",
    "title": "2  W02 dartR Intro",
    "section": "Winding up",
    "text": "Winding up\n\nDiscussion Time\nAdd some questions to help group discussion.\n\n\nWhere have we come?\nSummarise what they should have learnt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>W02 dartR Intro</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W03/W03.html",
    "href": "inst/tutorials/W03/W03.html",
    "title": "3  W03 Sex-Linked Markers",
    "section": "",
    "text": "W03 Sex-Linked Markers",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>W03 Sex-Linked Markers</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W03/W03.html#introduction",
    "href": "inst/tutorials/W03/W03.html#introduction",
    "title": "3  W03 Sex-Linked Markers",
    "section": "Introduction",
    "text": "Introduction\n\nLearning outcomes\nWhat is the goal of this session? What will participants learn?\n\n\nPrerquisites\nWhat prior knowledge do they need?\n\n\nWorkflow\nWhat is the structure of the session?\n\n\nAdditional reading\nAnything else you want to add?",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>W03 Sex-Linked Markers</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W03/W03.html#topic",
    "href": "inst/tutorials/W03/W03.html#topic",
    "title": "3  W03 Sex-Linked Markers",
    "section": "Topic",
    "text": "Topic\nBrief recap of the topic, relating back to the presentation.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>W03 Sex-Linked Markers</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W03/W03.html#worked-ex",
    "href": "inst/tutorials/W03/W03.html#worked-ex",
    "title": "3  W03 Sex-Linked Markers",
    "section": "Worked Ex:",
    "text": "Worked Ex:\nWorked example that everyone steps through together - simple example applying the methods\n\n# We show them the code to run",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>W03 Sex-Linked Markers</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W03/W03.html#exercises",
    "href": "inst/tutorials/W03/W03.html#exercises",
    "title": "3  W03 Sex-Linked Markers",
    "section": "Exercises",
    "text": "Exercises\nExercises where they can use their own data or supplied data to try out what they have learnt in a new context.\n\ndot points\nfor different steps",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>W03 Sex-Linked Markers</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W03/W03.html#winding-up",
    "href": "inst/tutorials/W03/W03.html#winding-up",
    "title": "3  W03 Sex-Linked Markers",
    "section": "Winding up",
    "text": "Winding up\n\nDiscussion Time\nAdd some questions to help group discussion.\n\n\nWhere have we come?\nSummarise what they should have learnt.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>W03 Sex-Linked Markers</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W04/W04.html",
    "href": "inst/tutorials/W04/W04.html",
    "title": "4  W04 Genetic Structure",
    "section": "",
    "text": "W04 Genetic Structure",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>W04 Genetic Structure</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W04/W04.html#introduction",
    "href": "inst/tutorials/W04/W04.html#introduction",
    "title": "4  W04 Genetic Structure",
    "section": "Introduction",
    "text": "Introduction\n\nLearning outcomes\nWhat is the goal of this session? What will participants learn?\n\n\nPrerquisites\nWhat prior knowledge do they need?\n\n\nWorkflow\nWhat is the structure of the session?\n\n\nAdditional reading\nAnything else you want to add?",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>W04 Genetic Structure</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W04/W04.html#topic",
    "href": "inst/tutorials/W04/W04.html#topic",
    "title": "4  W04 Genetic Structure",
    "section": "Topic",
    "text": "Topic\nBrief recap of the topic, relating back to the presentation.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>W04 Genetic Structure</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W04/W04.html#worked-ex",
    "href": "inst/tutorials/W04/W04.html#worked-ex",
    "title": "4  W04 Genetic Structure",
    "section": "Worked Ex:",
    "text": "Worked Ex:\nWorked example that everyone steps through together - simple example applying the methods\n\n# We show them the code to run",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>W04 Genetic Structure</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W04/W04.html#exercises",
    "href": "inst/tutorials/W04/W04.html#exercises",
    "title": "4  W04 Genetic Structure",
    "section": "Exercises",
    "text": "Exercises\nExercises where they can use their own data or supplied data to try out what they have learnt in a new context.\n\ndot points\nfor different steps",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>W04 Genetic Structure</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W04/W04.html#winding-up",
    "href": "inst/tutorials/W04/W04.html#winding-up",
    "title": "4  W04 Genetic Structure",
    "section": "Winding up",
    "text": "Winding up\n\nDiscussion Time\nAdd some questions to help group discussion.\n\n\nWhere have we come?\nSummarise what they should have learnt.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>W04 Genetic Structure</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W05/W05.html",
    "href": "inst/tutorials/W05/W05.html",
    "title": "5  W05 Calling SNPs",
    "section": "",
    "text": "W05 W05 Calling SNPs",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>W05 Calling SNPs</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W05/W05.html#introduction",
    "href": "inst/tutorials/W05/W05.html#introduction",
    "title": "5  W05 Calling SNPs",
    "section": "Introduction",
    "text": "Introduction\n\nLearning outcomes\nWhat is the goal of this session? What will participants learn?\n\n\nPrerquisites\nWhat prior knowledge do they need?\n\n\nWorkflow\nWhat is the structure of the session?\n\n\nAdditional reading\nAnything else you want to add?",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>W05 Calling SNPs</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W05/W05.html#topic",
    "href": "inst/tutorials/W05/W05.html#topic",
    "title": "5  W05 Calling SNPs",
    "section": "Topic",
    "text": "Topic\nBrief recap of the topic, relating back to the presentation.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>W05 Calling SNPs</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W05/W05.html#worked-ex",
    "href": "inst/tutorials/W05/W05.html#worked-ex",
    "title": "5  W05 Calling SNPs",
    "section": "Worked Ex:",
    "text": "Worked Ex:\nWorked example that everyone steps through together - simple example applying the methods\n\n# We show them the code to run",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>W05 Calling SNPs</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W05/W05.html#exercises",
    "href": "inst/tutorials/W05/W05.html#exercises",
    "title": "5  W05 Calling SNPs",
    "section": "Exercises",
    "text": "Exercises\nExercises where they can use their own data or supplied data to try out what they have learnt in a new context.\n\ndot points\nfor different steps",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>W05 Calling SNPs</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W05/W05.html#winding-up",
    "href": "inst/tutorials/W05/W05.html#winding-up",
    "title": "5  W05 Calling SNPs",
    "section": "Winding up",
    "text": "Winding up\n\nDiscussion Time\nAdd some questions to help group discussion.\n\n\nWhere have we come?\nSummarise what they should have learnt.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>W05 Calling SNPs</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W06/W06.html",
    "href": "inst/tutorials/W06/W06.html",
    "title": "6  W06 Small Populations",
    "section": "",
    "text": "W06 Management of Small Populations",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>W06 Small Populations</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W06/W06.html#introduction",
    "href": "inst/tutorials/W06/W06.html#introduction",
    "title": "6  W06 Small Populations",
    "section": "Introduction",
    "text": "Introduction\n\nLearning outcomes\nWhat is the goal of this session? What will participants learn?\n\n\nPrerquisites\nWhat prior knowledge do they need?\n\n\nWorkflow\nWhat is the structure of the session?\n\n\nAdditional reading\nAnything else you want to add?",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>W06 Small Populations</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W06/W06.html#topic",
    "href": "inst/tutorials/W06/W06.html#topic",
    "title": "6  W06 Small Populations",
    "section": "Topic",
    "text": "Topic\nBrief recap of the topic, relating back to the presentation.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>W06 Small Populations</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W06/W06.html#worked-ex",
    "href": "inst/tutorials/W06/W06.html#worked-ex",
    "title": "6  W06 Small Populations",
    "section": "Worked Ex:",
    "text": "Worked Ex:\nWorked example that everyone steps through together - simple example applying the methods\n\n# We show them the code to run",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>W06 Small Populations</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W06/W06.html#exercises",
    "href": "inst/tutorials/W06/W06.html#exercises",
    "title": "6  W06 Small Populations",
    "section": "Exercises",
    "text": "Exercises\nExercises where they can use their own data or supplied data to try out what they have learnt in a new context.\n\ndot points\nfor different steps",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>W06 Small Populations</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W06/W06.html#winding-up",
    "href": "inst/tutorials/W06/W06.html#winding-up",
    "title": "6  W06 Small Populations",
    "section": "Winding up",
    "text": "Winding up\n\nDiscussion Time\nAdd some questions to help group discussion.\n\n\nWhere have we come?\nSummarise what they should have learnt.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>W06 Small Populations</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W07/W07.html",
    "href": "inst/tutorials/W07/W07.html",
    "title": "7  Effective Population Size",
    "section": "",
    "text": "W07 Effective Population Size",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Effective Population Size</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W07/W07.html#effective-population-size",
    "href": "inst/tutorials/W07/W07.html#effective-population-size",
    "title": "7  Effective Population Size",
    "section": "Effective Population Size",
    "text": "Effective Population Size\nSession Presenters",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Effective Population Size</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W07/W07.html#learning-outcomes",
    "href": "inst/tutorials/W07/W07.html#learning-outcomes",
    "title": "7  Effective Population Size",
    "section": "Learning Outcomes",
    "text": "Learning Outcomes\nIn this session we will learn how to estimate effective population size (Ne) using genomic SNP data. We start with the theoretical background, then move to two practical approaches: (1) the linkage disequilibrium method for contemporary Ne, and (2) the Site Frequency Spectrum (SFS) / coalescent approach for historical Ne. By the end of this tutorial you should be able to:\n\nExplain the concept of Ne and why it differs from census size (Nc)\nDistinguish between drift, LD-based, and coalescent Ne estimators\nRun a linkage disequilibrium Ne estimate using gl.LDNe in the dartRverse, and understand the role of MAF filtering\nCompute a Site Frequency Spectrum (SFS) from SNP data and interpret its shape\nEstimate historical Ne trajectories using EPOS, and understand the role of L and mu\n\nAppreciate the differences and complementarity of EPOS and Stairways2",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Effective Population Size</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W07/W07.html#introduction-what-is-effective-population-size",
    "href": "inst/tutorials/W07/W07.html#introduction-what-is-effective-population-size",
    "title": "7  Effective Population Size",
    "section": "Introduction: What is Effective Population Size?",
    "text": "Introduction: What is Effective Population Size?\n\nThe concept of Ne\nEffective population size (Ne) is one of the most fundamental concepts in conservation genetics. It represents the size of an idealised population that would experience genetic drift, accumulate inbreeding, or generate linkage disequilibrium at the same rate as the real population under study.\nAn idealised population has: equal sex ratio, random mating (panmixia), non-overlapping generations, constant population size over time, and no selection, mutation, or migration.\nThe actual census size (Nc) — the number of individuals you count in the field — is almost always larger than Ne, often dramatically so. The ratio Ne/Nc is typically 0.1–0.5 for vertebrates but can be far smaller in species with highly skewed reproductive success.\nWhy is Ne &lt; Nc?\n\nUnequal sex ratios (e.g. polygynous mating systems where few males do most of the breeding)\nHigh variance in reproductive success (some individuals contribute many offspring, others none)\nPopulation size fluctuations over time (the harmonic mean penalises bottlenecks severely)\nOverlapping generations\nPopulation subdivision and restricted gene flow\n\n\n\nWhy does Ne matter for conservation?\nThe rate at which a population loses genetic diversity through drift is governed directly by Ne:\n\\[H_t = H_0 \\left(1 - \\frac{1}{2N_e} \\right)^t\\]\nwhere H₀ is initial heterozygosity and H_t is heterozygosity after t generations. The practical implications are stark:\n\nA population with Ne = 50 loses ~1% of its heterozygosity per generation\nA population with Ne = 500 loses only ~0.1% per generation\nA population with Ne = 10 loses nearly 5% per generation — catastrophically fast\n\nThis is the basis of the 50/500 rule (Franklin 1980, Soule 1986): a minimum Ne of 50 is needed to avoid severe short-term inbreeding depression, and Ne ≥ 500 (more recently revised upward to ~1000) to maintain long-term evolutionary potential. This is a rule of thumb, not a rigid target — it should be applied alongside species-specific biological knowledge.\n\n\n\nThe many versions of Ne: which one are you estimating?\nA critical and often overlooked point is that different methods estimate different things. The term “effective population size” covers several conceptually distinct quantities:\nDrift Ne is estimated from the change in allele frequencies between two time points (the temporal method). It reflects the rate of allelic drift between samples. Requires sampling the population at two or more time points.\nInbreeding Ne is estimated from pedigrees or genomic excess homozygosity. It reflects the rate at which individuals become more related to each other over time.\nLinkage Disequilibrium Ne (LD Ne) is estimated from the extent of background LD among loci in a single sample. In a finite population, drift creates associations between alleles at unlinked loci — the smaller Ne, the stronger this background LD. This gives a contemporary Ne, reflecting the effective size over the past few generations. This is what NeEstimator / gl.LDNe calculates.\nCoalescent Ne is estimated from the genealogical history of alleles using the Site Frequency Spectrum (SFS). Different lineages coalesce at rates that depend on Ne, so the distribution of allele frequencies carries a signal of historical Ne over hundreds to thousands of generations. EPOS and Stairways2 use this approach.\n\nKey message: All Ne estimators compare the observed population to an idealised population, but at different timescales and using different signals. Do not directly compare a contemporary LD Ne to a coalescent Ne without careful consideration — they are measuring related but distinct quantities.\n\n\n## Setup\n\nlibrary(dartRverse)  #version 1.1.2 or higher\nlibrary(ggplot2) #for plotting\nlibrary(tidyr)\nlibrary(patchwork)",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Effective Population Size</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W07/W07.html#part-1-contemporary-ne-the-linkage-disequilibrium-method",
    "href": "inst/tutorials/W07/W07.html#part-1-contemporary-ne-the-linkage-disequilibrium-method",
    "title": "7  Effective Population Size",
    "section": "Part 1: Contemporary Ne — The Linkage Disequilibrium Method",
    "text": "Part 1: Contemporary Ne — The Linkage Disequilibrium Method\n\nThe LD approach\nThe LD method estimates Ne from a single sample by measuring background linkage disequilibrium among loci. In an infinitely large population, unlinked loci should be in linkage equilibrium. In a finite population, drift generates LD even among physically unlinked loci. The smaller Ne, the stronger this background LD. The expected squared correlation between alleles at two unlinked loci is approximately (Waples 2006):\n\\[E[\\hat{r}^2] \\approx \\frac{1}{3 N_e} + \\frac{1}{S}\\]\nwhere S is the sample size. The 1/S term is sampling noise and is added (subtracted) to isolate the drift-induced LD. This is implemented in the NeEstimator software, accessed via gl.LDNe in the dartRverse.\nKey assumptions:\n\nLoci are in approximate Hardy–Weinberg equilibrium\nNo strong selection at the measured loci\nThe sample is representative of a single well-mixed population\n\n\n\nThe critical role of MAF filtering\nOne of the most important quality choices for LD Ne is the minor allele frequency (MAF) threshold, set with the critical argument. Rare alleles (very low MAF) are problematic because:\n\nTheir frequencies are estimated with high uncertainty, especially in small samples\nThey tend to inflate \\(\\hat{r}^2\\) (apparent LD), which biases Ne downward\nThey may reflect genotyping errors more than true biological signal\n\nThe standard recommendation is MAF ≥ 0.05 (critical = 0.05), removing loci where the minor allele occurs in fewer than 5% of gene copies. This balances accuracy (higher threshold is better) against precision (more loci retained means more precise estimates).\n\nStandard practice: use critical = c(0, 0.05) to compare the unfiltered and MAF-filtered estimates simultaneously. If the two estimates differ markedly, the unfiltered estimate is likely biased by rare alleles.\n\n\n\nRunning LD Ne with gl.LDNe\nSimulate a population with a known Ne of 50 and estimate it:\n\n# First, download the NeEstimator binary (only necessary once)\ndir_ne &lt;- gl.download.binary(\"neestimator\", out.dir = tempdir())\n\nDownloaded binary to  C:\\Users\\s425824\\AppData\\Local\\Temp\\RtmpGCG9y2\\filef406d6d1386 \nUnzipped binary to C:\\Users\\s425824\\AppData\\Local\\Temp\\RtmpGCG9y2/neestimator\n\n# Simulate 50 individuals with 3000 loci\nsim50 &lt;- gl.sim.Neconst(ninds = 50, nlocs = 3000)\n\n# Run a few generations of random mating to approach HWE\nfor (i in 1:5) {\n  sim50 &lt;- gl.sim.offspring(sim50, sim50, noffpermother = 1)\n}\n\n\n\n\n# Estimate Ne using LD method\n# critical = c(0, 0.05): once without MAF filter, once with MAF &gt;= 5%\nne_result &lt;- gl.LDNe(sim50,\n                     outfile      = \"sim50LD.txt\",\n                     neest.path   = dir_ne,\n                     critical     = c(0, 0.05),\n                     singleton.rm = TRUE,\n                     mating       = \"random\")\n\nStarting gl.LDNe \n  Processing genlight object with SNP data\nStarting gl2genepop \n  Processing genlight object with SNP data\n  The genepop file is saved as:  C:\\Users\\s425824\\AppData\\Local\\Temp\\RtmpGCG9y2/dummy.gen/\nCompleted: gl2genepop \n  Processing genlight object with SNP data\n\n\n\n\n\n\n\n\n\n$offspring_Po\n                    Statistic Frequency 1 Frequency 2 Frequency 3\n Lowest Allele Frequency Used       0.050          0+       No S*\n    Harmonic Mean Sample Size          50          50          50\n      Independent Comparisons     1131760     1919820     1721440\n                  OverAll r^2    0.026552    0.025671    0.026087\n          Expected r^2 Sample    0.021276    0.021276    0.021276\n                Estimated Ne^          61        73.7        67.1\n            CI low Parametric        60.2        72.8        66.4\n           CI high Parametric        61.9        74.6          68\n             CI low JackKnife          52        62.4        56.6\n            CI high JackKnife          73        89.1        81.5\n\n  The results are saved in: C:\\Users\\s425824\\AppData\\Local\\Temp\\RtmpGCG9y2/sim50LD.txt \nCompleted: gl.LDNe \n\n\nThe output shows two rows — one for each critical value. The estimate with critical = 0.05 should be closer to the true Ne of 50.\n\n### Exercise 1: Effect of MAF threshold on Ne estimates\n\n\n\n\n\n\nNoneExercise: gl.LDNe and MAF filtering\n\n\n\nRerun the example above for different simulated datasets (or your own) Be aware that filtering your dataset is important You want to have high quality data with minimal missingness, and a good number of loci after filtering. Also you would like to have a reasonable sample size (S &gt;= 30) to avoid technical artefacts. Finally maf filtering is critical for accurate estimates, so you should run with a range of thresholds to see how it affects the estimate. For example, you could run with critical = c(0, 0.02, 0.05, 0.10) to see how the estimate changes as you increase the MAF threshold. Definitely remove singletons in most cases.\nQUESTIONS: - How does the Ne estimate change as you increase the MAF threshold? - At which threshold does the estimate stabilise? - What are the trade-offs of using very high vs very low MAF thresholds? - What happens if you do not use the HWE simulation step?\n\n\n\n\n\ndir_ne &lt;- gl.download.binary(\"neestimator\", out.dir = tempdir())\n\n# Simulate 50 individuals with 3000 loci\nsim50 &lt;- gl.sim.Neconst(ninds = 50, nlocs = 3000)\n\n# Run a few generations of random mating to approach HWE\nfor (i in 1:5) {\n  sim50 &lt;- gl.sim.offspring(sim50, sim50, noffpermother = 1)\n}\n\n\n\n\n# Estimate Ne using LD method\n# critical = c(0, 0.05): once without MAF filter, once with MAF &gt;= 5%\nne_result &lt;- gl.LDNe(sim50,\n                     outfile      = \"sim50LD.txt\",\n                     neest.path   = dir_ne,\n                     critical     = c(0, 0.05),\n                     singleton.rm = TRUE,\n                     mating       = \"random\")\n\n\n\n\n\n\n\nThe Waples correction for genomic data\nWhen thousands of SNPs are available and a genome map exists, physically linked loci on the same chromosome show LD due to recombination — not just drift. This inflates apparent LD and biases Ne downward. Waples et al. (2016) showed that restricting analysis to inter-chromosomal locus pairs (pairing = \"separate\") corrects for physical linkage and produces improved estimates.\n\npops &lt;- possums.gl[1:60, 1:100]\n# Assign chromosome information (illustrative — use real data in practice)\npops@chromosome &lt;- as.factor(sample(1:10, size = nLoc(pops), replace = TRUE))\n\nne_separate &lt;- gl.LDNe(pops,\n                       outfile      = \"popsLD_sep.txt\",\n                       pairing      = \"separate\",\n                       neest.path   = dir_ne,\n                       critical     = c(0, 0.05),\n                       singleton.rm = TRUE,\n                       mating       = \"random\")\n\nStarting gl.LDNe \n  Processing genlight object with SNP data\nStarting gl2genepop \n  Processing genlight object with SNP data\n  The genepop file is saved as:  C:\\Users\\s425824\\AppData\\Local\\Temp\\RtmpGCG9y2/dummy.gen/\nCompleted: gl2genepop \n  Processing genlight object with SNP data\n\n\n\n\n\n\n\n\n\n$A\n                    Statistic Frequency 1 Frequency 2 Frequency 3\n Lowest Allele Frequency Used       0.050          0+       No S*\n    Harmonic Mean Sample Size          30          30          30\n      Independent Comparisons        3001        3542        3380\n                  OverAll r^2    0.056843    0.055144    0.055995\n          Expected r^2 Sample    0.036878    0.036878    0.036878\n                Estimated Ne^        13.5          15        14.2\n            CI low Parametric        11.4        12.8        12.1\n           CI high Parametric          16        17.6        16.7\n             CI low JackKnife         8.4          10         9.5\n            CI high JackKnife        22.8        23.6        22.3\n\n$B\n                    Statistic Frequency 1 Frequency 2 Frequency 3\n Lowest Allele Frequency Used       0.050          0+       No S*\n    Harmonic Mean Sample Size          30          30          30\n      Independent Comparisons        4125        4471        4125\n                  OverAll r^2    0.053429    0.052373    0.053429\n          Expected r^2 Sample    0.036878    0.036878    0.036878\n                Estimated Ne^        16.7          18        16.7\n            CI low Parametric        14.4        15.5        14.4\n           CI high Parametric        19.7        21.2        19.7\n             CI low JackKnife        11.5        12.2        11.5\n            CI high JackKnife        25.8        28.5        25.8\n\n  The results are saved in: C:\\Users\\s425824\\AppData\\Local\\Temp\\RtmpGCG9y2/popsLD_sep.txt \nCompleted: gl.LDNe \n\n\nIf chromosome data is unavailable but the number of chromosomes (or genome length) is known, apply a numerical correction from Waples et al. (2016):\n\nne_corrected &lt;- gl.LDNe(pops,\n                        outfile                 = \"popsLD_corr.txt\",\n                        neest.path              = dir_ne,\n                        critical                = c(0, 0.05),\n                        singleton.rm            = TRUE,\n                        mating                  = \"random\",\n                        Waples.correction       = 'nChromosomes',\n                        Waples.correction.value = 22)\n\nStarting gl.LDNe \n  Processing genlight object with SNP data\nStarting gl2genepop \n  Processing genlight object with SNP data\n  The genepop file is saved as:  C:\\Users\\s425824\\AppData\\Local\\Temp\\RtmpGCG9y2/dummy.gen/\nCompleted: gl2genepop \n  Processing genlight object with SNP data\n\n\n\n\n\n\n\n\n\n$A\n                            Statistic Frequency 1 Frequency 2 Frequency 3\n         Lowest Allele Frequency Used       0.050          0+       No S*\n            Harmonic Mean Sample Size          30          30          30\n              Independent Comparisons        3321        3916        3741\n                          OverAll r^2    0.056847    0.055101    0.055956\n                  Expected r^2 Sample    0.036878    0.036878    0.036878\n                        Estimated Ne^        13.5          15        14.2\n                    CI low Parametric        11.5        12.9        12.2\n                   CI high Parametric        15.9        17.5        16.6\n                     CI low JackKnife         8.3         9.9         9.4\n                    CI high JackKnife          23        23.9        22.6\n                 Waples' corrected Ne        17.4        19.4        18.3\n  Waples' corrected CI low Parametric        14.8        16.6        15.7\n Waples' corrected CI high Parametric        20.5        22.6        21.4\n   Waples' corrected CI low JackKnife        10.7        12.8        12.1\n  Waples' corrected CI high JackKnife        29.7        30.8        29.2\n\n$B\n                            Statistic Frequency 1 Frequency 2 Frequency 3\n         Lowest Allele Frequency Used       0.050          0+       No S*\n            Harmonic Mean Sample Size          30          30          30\n              Independent Comparisons        4560        4950        4560\n                          OverAll r^2    0.054024    0.052873    0.054024\n                  Expected r^2 Sample    0.036878    0.036878    0.036878\n                        Estimated Ne^        16.1        17.4        16.1\n                    CI low Parametric        13.9        15.1        13.9\n                   CI high Parametric        18.7        20.2        18.7\n                     CI low JackKnife          11        11.7          11\n                    CI high JackKnife        24.7        27.6        24.8\n                 Waples' corrected Ne        20.8        22.5        20.8\n  Waples' corrected CI low Parametric        17.9        19.5        17.9\n Waples' corrected CI high Parametric        24.1        26.1        24.1\n   Waples' corrected CI low JackKnife        14.2        15.1        14.2\n  Waples' corrected CI high JackKnife        31.9        35.6          32\n\n  The results are saved in: C:\\Users\\s425824\\AppData\\Local\\Temp\\RtmpGCG9y2/popsLD_corr.txt \nCompleted: gl.LDNe \n\n\n\n\nUnderstanding Inf estimates\nSometimes gl.LDNe returns Ne = Inf. This typically means the population is very large (negligible drift-induced LD), but it can also arise as a technical artefact. For random mating with S &gt;= 30 individuals, the bias-corrected formula is:\n\\[N_e = \\frac{1/3 + \\sqrt{1/9 - 2.76\\hat{r}^{2\\prime}}}{2\\hat{r}^{2\\prime}}\\]\nWhen the corrected \\(\\hat{r}^{2\\prime}\\) is very small or negative (which can happen with small samples and rare alleles), the square root becomes undefined and Ne is reported as Inf. The naive = TRUE option skips the bias correction and helps diagnose the source:\n\nne_naive &lt;- gl.LDNe(pops,\n                    outfile      = \"popsLD_naive.txt\",\n                    neest.path   = dir_ne,\n                    critical     = c(0, 0.05),\n                    singleton.rm = TRUE,\n                    mating       = \"random\",\n                    naive        = TRUE)\n\nPractical remedies for Inf estimates:\n\nIncrease the MAF threshold to remove rare, noisy alleles\nCheck whether sample size is very small (S &lt; 20 is problematic)\nIf Inf persists across thresholds and with naive = TRUE, it likely reflects a genuinely large population, but be cautious about over-interpreting Inf as “very large” — it may simply mean “too large to estimate with this method and data quality”.\n\n\n\n\n\n\n\n\nNoneExercise 2: Diagnosing Ne with different population sizes\n\n\n\nSimulate two populations: - (a) ninds = 200, nlocs = 1000 — a large population - (b) ninds = 20, nlocs = 1000 — a small population - For each, run 3 generations of random mating, then estimate Ne with gl.LDNe. - Use critical = c(0, 0.05).\nQuestions: - Do you get Inf estimates for the larger population? - Does the MAF filter help? - How close are the estimates to the true Ne?\nPlease note the estimates are pretty good because those are simulated data sets, hence the assumptions of the method are met. In real data, estimates can be more biased and imprecise due to violations of assumptions, genotyping errors, and other complexities. The key is to understand the limitations and interpret results in context.\n\n\n\n\n\n# EXERCISE:\n# Simulate two populations:\n#   (a) ninds = 200, nlocs = 1000  — a large population\n#   (b) ninds = 20,  nlocs = 1000  — a small population\n#\n# For each, run 3 generations of random mating, then estimate Ne with gl.LDNe.\n# Use critical = c(0, 0.05).\n#\n# QUESTIONS:\n# - Do you get Inf estimates for the larger population?\n# - Does the MAF filter help?\n# - How close are the estimates to the true Ne?\n\ndir_ne &lt;- gl.download.binary(\"neestimator\", out.dir = tempdir())\n\n# Large population (true Ne ~ 200)\nsim200 &lt;- gl.sim.Neconst(ninds = 200, nlocs = 1000)\nfor (i in 1:3) sim200 &lt;- gl.sim.offspring(sim200, sim200, noffpermother = 1)\n\n# Small population (true Ne ~ 20)\nsim20 &lt;- gl.sim.Neconst(ninds = 20, nlocs = 1000)\nfor (i in 1:3) sim20 &lt;- gl.sim.offspring(sim20, sim20, noffpermother = 1)\n\n# Run gl.LDNe for both and compare:",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Effective Population Size</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W07/W07.html#part-2-historical-ne-the-site-frequency-spectrum-approach",
    "href": "inst/tutorials/W07/W07.html#part-2-historical-ne-the-site-frequency-spectrum-approach",
    "title": "7  Effective Population Size",
    "section": "Part 2: Historical Ne — The Site Frequency Spectrum Approach",
    "text": "Part 2: Historical Ne — The Site Frequency Spectrum Approach\n\nWhat is the Site Frequency Spectrum?\nThe Site Frequency Spectrum (SFS) — also called the allele frequency spectrum — counts how many SNPs in your dataset carry their minor allele at each possible frequency. For a sample of n diploid individuals (2n gene copies), the folded SFS tabulates SNPs from minor allele frequency (MAF) = 1/(2n) up to 0.5.\nThe shape of the SFS carries a demographic signal:\n\n\n\n\n\n\n\nDemographic event\nEffect on SFS\n\n\n\n\nConstant population\nExponential decay (many rare, few common alleles)\n\n\nRecent population decline\nExcess of intermediate-frequency alleles\n\n\nRecent population expansion\nExcess of rare alleles (singletons) relative to intermediate frequencies\n\n\nSevere bottleneck\nStrong excess of singletons\n\n\n\nCoalescent theory provides the mathematical link between the SFS and historical Ne: the rate at which lineages coalesce in the past depends on Ne at that time. By fitting a model to the observed SFS, we can infer how Ne has changed over time. This is what EPOS and Stairways2 do.\n\n\n2.1 Computing the SFS in the dartRverse\nThe gl.sfs function computes the SFS from a genlight/dartR object. Before computing the SFS, filter your data carefully:\n\nMinimal missing data (the SFS is sensitive to missingness, which distorts allele frequencies)\nMonomorphic loci removed\nGood call rates per locus and per individual\n\n\n# Example filtering workflow for real data\nnorth  &lt;- readRDS(file.path(path.data, \"TympoNorth.rds\"))\nnorth2 &lt;- gl.filter.callrate(north,  method = \"loc\", threshold = 0.95)\n\nStarting gl.filter.callrate \n  Processing genlight object with SNP data\n  Warning: data include loci that are scored NA across all individuals.\n  Consider filtering using gl &lt;- gl.filter.allna(gl)\n  Warning: Data may include monomorphic loci in call rate \n                    calculations for filtering\n  Recalculating Call Rate\n  Removing loci based on Call Rate, threshold = 0.95 \n\n\n\n\n\n\n\n\n\nCompleted: gl.filter.callrate \n\nnorth3 &lt;- gl.filter.rdepth(north2,   lower = 10, upper = 40)\n\nStarting gl.filter.rdepth \n  Processing genlight object with SNP data\n  Removing loci with rdepth &lt;= 10 and &gt;= 40 \n\n\n\n\n\n\n\n\n\nCompleted: gl.filter.rdepth \n\nnorth4 &lt;- gl.filter.monomorphs(north3)\n\nStarting gl.filter.monomorphs \n  Processing genlight object with SNP data\n  Identifying monomorphic loci\n  Removing monomorphic loci and loci with all missing \n                       data\nCompleted: gl.filter.monomorphs \n\nnorth5 &lt;- gl.filter.callrate(north4, threshold = 0.9, method = \"ind\")\n\nStarting gl.filter.callrate \n  Processing genlight object with SNP data\n  Recalculating Call Rate\n  Removing individuals based on Call Rate, threshold = 0.9 \n\n\n\n\n\n\n\n\n\n  Note: Locus metrics not recalculated\n  Note: Resultant monomorphic loci not deleted\nCompleted: gl.filter.callrate \n\nnInd(north5)\n\n[1] 121\n\nnLoc(north5)\n\n[1] 10832\n\n\nNow compute the SFS from a simulated dataset:\n\n# Load a simulated dataset with constant Ne = 100\ngl100 &lt;- readRDS(file.path(path.data, \"slim_100.rds\"))\n\nnInd(gl100)\nnLoc(gl100)\n\n# Folded SFS (default — use when ancestral allele state is unknown)\nsfs_const &lt;- gl.sfs(gl100, folded = TRUE)\nsfs_const\n\n# Unfolded SFS (requires knowledge of the ancestral allele)\nsfs_unfolded &lt;- gl.sfs(gl100, folded = FALSE)\nsfs_unfolded\n\nThe minbinsize argument controls whether the lowest-frequency bins are included. minbinsize = 1 retains singletons. In real data, singletons can be inflated by sequencing errors, so minbinsize = 2 or higher is common for empirical datasets. However, removing too many bins loses demographic information — the lowest bins carry the strongest signal about recent events.\n\n### Exercise 3: Exploring the SFS\n\n\n\n# EXERCISE:\n# Using an example data set \n# Steps:\n#   1. gl.filter.callrate(method = \"loc\", threshold = 0.95) to filter missing data\n#   2. gl.filter.monomorphs() to remove invariant loci\n#   3. gl.sfs(folded = TRUE) with minbinsize = 1 and then minbinsize = 5\n#\n# QUESTIONS:\n# - What does the SFS look like? Does it suggest recent expansion or contraction?\n# - How does changing minbinsize affect the number of SNPs in the spectrum?\n# - When would you use a higher minbinsize in real data?\n\nglex    &lt;- readRDS(file.path(path.data, \"slim_ex.rds\"))\n\n\n\n\n\n\n\n2.2 Comparing SFS shapes across demographic scenarios\nLet us compare four simulated datasets to build intuition about SFS shapes under different demographic histories.\n\n# Load four simulated datasets with known demographic histories\ngl100    &lt;- readRDS(file.path(path.data, \"slim_100.rds\"))\ngldec    &lt;- readRDS(file.path(path.data, \"slim_100_50_50yago.rds\"))\nglinc    &lt;- readRDS(file.path(path.data, \"slim_100_200_50yago.rds\"))\nglbottle &lt;- readRDS(file.path(path.data, \"slim_100_10_50_50yago_10year.rds\"))\n\n# Compute SFS for each scenario\nsfs_const  &lt;- gl.sfs(gl100,    folded = TRUE)\nsfs_dec    &lt;- gl.sfs(gldec,    folded = TRUE)\nsfs_inc    &lt;- gl.sfs(glinc,    folded = TRUE)\nsfs_bottle &lt;- gl.sfs(glbottle, folded = TRUE)\n\n# Combine into a single data frame and plot\ndf &lt;- data.frame(\n  x          = 0:50,\n  Constant   = as.numeric(sfs_const),\n  Decline    = as.numeric(sfs_dec),\n  Increase   = as.numeric(sfs_inc),\n  Bottleneck = as.numeric(sfs_bottle)\n)\n\ndf_long &lt;- tidyr::pivot_longer(df, -x, names_to = \"Scenario\", values_to = \"Count\")\n\nggplot(df_long, aes(x = x, y = Count)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  facet_wrap(~Scenario, scales = \"free_y\") +\n  labs(x     = \"Minor allele frequency class\",\n       y     = \"Number of SNPs\",\n       title = \"SFS shapes under different demographic histories\") + ylim(c(0,4000))\n  theme_bw()\n\nOnce you can see four different sfs within a panel you can clearly see the effect of historic population sizes. Mind you those data sets\nDifferences between SFS shapes can be subtle visually. This is why formal inference methods are needed — human visual comparison of SFS plots is unreliable, especially for mild or recent demographic events. If you have a real dataset it might be a good idea to simulate data for a certain trajectory using your sample sizes and number of SNPs and then compare this to your sfs.\n\n\n\n2.3 Estimating historical Ne with EPOS\nEPOS (Lynch et al. 2019) estimates the historical Ne trajectory using a fast semi-analytical optimisation applied to the SFS. We use EPOS in this tutorial because it runs in seconds to minutes rather than the hours required by Stairways2, while producing broadly comparable results.\n\nThe key parameters: L and mu\nEPOS requires two parameters to place the inferred trajectory on an absolute scale:\n\nL — the total length of the genome region that was sequenced (base pairs). This is not the number of SNPs, but the total sequence length surveyed — the “opportunity” for mutations to occur.\nmu — the per-site per-generation mutation rate.\n\nThese together determine the expected number of mutations per generation:\n\\[x = \\mu \\times L \\times 2 \\times N_e\\]\nIf L or mu is wrong, the shape of the trajectory is usually preserved but the absolute axis values (Ne and generations) will be off. For within-dataset comparisons, the trajectory shape is more robust. For comparing absolute Ne across datasets or species, getting L and mu right is essential.\nFor simulated data: L and mu are known exactly.\nFor DArTseq data: A common approximation is L = nLoc * 75 * 200 (loci × tag length ~75 bp × ~200 to account for sampling fraction). Alternatively, L can be estimated using Watterson’s formula (see Exercise B). Species-specific mutation rates should be used where available; a vertebrate default is often mu = 1e-8.\nFirst, download EPOS:\n\ndir_epos &lt;- gl.download.binary(\"epos\", out.dir = tempdir())\n\nRun EPOS on the constant Ne = 100 simulation:\n\nL  &lt;- 5e8   # total genome length from simulation (known)\nmu &lt;- 1e-8  # mutation rate from simulation (known)\n\nNe_epos &lt;- gl.epos(gl100,\n                   epos.path  = path.binaries,\n                   l          = L,\n                   u          = mu,\n                   boot       = 10,\n                   minbinsize = 1)\n\ncolnames(Ne_epos) &lt;- c(\"generation\", \"low\", \"Ne_median\", \"high\")\n\nggplot(Ne_epos, aes(x = generation, y = Ne_median)) +\n  geom_line(colour = \"steelblue\", linewidth = 1) +\n  geom_ribbon(aes(ymin = low, ymax = high), alpha = 0.2, fill = \"steelblue\") +\n  labs(x     = \"Generations ago\",\n       y     = \"Effective population size (Ne)\",\n       title = \"EPOS estimate: constant Ne = 100\") +\n  theme_bw()\n\nThe median should hover around Ne = 100 throughout. Confidence intervals widen in the most recent time periods (too few mutations have accumulated for precise estimation) and in the deepest past (the coalescent is poorly resolved by a finite sample).\n\n\nWhat happens with a wrong L?\n\n# Common but incorrect approximation: nLoc * 69 bp\nL_wrong &lt;- 69 * nLoc(gl100)\n\nNe_epos_wrong &lt;- gl.epos(gl100,\n                         epos.path  = path.binaries,\n                         l          = L_wrong,\n                         u          = mu,\n                         boot       = 10,\n                         minbinsize = 1)\n\ncolnames(Ne_epos_wrong) &lt;- c(\"generation\", \"low\", \"Ne_median\", \"high\")\n\nggplot(Ne_epos_wrong, aes(x = generation, y = Ne_median)) +\n  geom_line(colour = \"tomato\", linewidth = 1) +\n  geom_ribbon(aes(ymin = low, ymax = high), alpha = 0.2, fill = \"tomato\") +\n  labs(x     = \"Generations ago\",\n       y     = \"Ne\",\n       title = paste0(\"EPOS with L = nLoc x 69 = \", L_wrong, \" (incorrect)\")) +\n  theme_bw()\n\nThe trajectory shape is preserved, but absolute axis values are badly wrong. Setting L too low inflates the inferred Ne — the same number of observed mutations must be explained by a smaller genome, implying a larger population. Importantly, the relative pattern of increases and decreases remains informative even when L is misspecified.\n\n\n\n\nExercise 4: Run EPOS on all demographic scenarios\n\n\n\n# EXERCISE:\n# Run EPOS on all four simulated datasets (gl100, glinc, gldec, glbottle).\n# Use L = 5e8 and mu = 1e-8 for all four.\n# Plot the four Ne trajectories side by side.\n#\n# QUESTIONS:\n# - Can EPOS correctly identify the direction of demographic change?\n# - How well does it recover the timing of the change?\n# - Which scenario is hardest to recover? Why?\n\nL  &lt;- 5e8\nmu &lt;- 1e-8\n\ngl100    &lt;- readRDS(file.path(path.data, \"slim_100.rds\"))\ngldec    &lt;- readRDS(file.path(path.data, \"slim_100_50_50yago.rds\"))\nglinc    &lt;- readRDS(file.path(path.data, \"slim_100_200_50yago.rds\"))\nglbottle &lt;- readRDS(file.path(path.data, \"slim_100_10_50_50yago_10year.rds\"))\n\n# Tip: run gl.epos() on each, then use patchwork to plot them together:\n# p1 + p2 + p3 + p4\n\n\n\n\n\n\n\n2.4 A real-data example\nHere we apply the full workflow to a real SNP dataset from northern brush-tailed possums (Trichosurus vulpecula, Tympo North population). The main difference from simulated data is that L must be approximated.\n\n# Load and filter real data\nnorth  &lt;- readRDS(file.path(path.data, \"TympoNorth.rds\"))\nnorth2 &lt;- gl.filter.callrate(north,  method = \"loc\", threshold = 0.95)\nnorth3 &lt;- gl.filter.rdepth(north2,   lower = 10, upper = 40)\nnorth4 &lt;- gl.filter.monomorphs(north3)\nnorth5 &lt;- gl.filter.callrate(north4, threshold = 0.9, method = \"ind\")\n\nnInd(north5)\nnLoc(north5)\n\n# For DArT data: L ~ nLoc * 75 bp * 200\nL_real  &lt;- nLoc(north5) * 75 * 200\nmu_real &lt;- 16.17e-9     # possum-specific estimate\n\n# Run EPOS\nNe_north &lt;- gl.run.epos(north5,\n                        epos.path  = path.binaries,\n                        L          = L_real,\n                        u          = mu_real,\n                        method     = \"greedy\",\n                        depth      = 2,\n                        boot       = 5)\nNe_north$plot\n\n\n\n\n2.5 Stairways2 — an alternative coalescent method\nStairways2 (Liu & Fu 2020) is the most widely used method for historical Ne inference from the SFS. It uses a machine learning approach to explore the demographic parameter space more thoroughly than EPOS’s semi-analytical optimisation, which may give an advantage for complex multi-epoch histories.\nThe key trade-off is computational time: a Stairways2 run that takes 5–60 minutes can be accomplished in seconds with EPOS, and results are often broadly similar. Our recommended workflow is:\n\nUse EPOS for rapid exploration and quality checking\nUse Stairways2 for final publishable results when time allows\n\nBoth methods use the same inputs (L, mu, minbinsize), so the discussion above applies equally to both, and results are directly comparable.\n\n# Stairways2 is slow (5+ minutes) — run and save, then load results\n# Un-comment to actually run:\n# Ne_sw &lt;- gl.stairway2(gl100,\n#                       stairway.path = path.binaries,\n#                       mu            = 1e-8,\n#                       gentime       = 1,\n#                       run           = TRUE,\n#                       nreps         = 30,\n#                       parallel      = 4,\n#                       L             = 5e8,\n#                       minbinsize    = 1)\n# saveRDS(Ne_sw, file.path(path.data, \"Ne_sw_gl100.rds\"))\n\n# Load pre-computed result\nNe_sw &lt;- readRDS(file.path(path.data, \"Ne_sw_gl100.rds\"))\n\nggplot(Ne_sw, aes(x = year, y = Ne_median)) +\n  geom_line(colour = \"steelblue\", linewidth = 1) +\n  geom_ribbon(aes(ymin = Ne_2.5., ymax = Ne_97.5.),\n              alpha = 0.2, fill = \"steelblue\") +\n  labs(x     = \"Years ago\",\n       y     = \"Effective population size (Ne)\",\n       title = \"Stairways2: constant Ne = 100\") +\n  theme_bw()\n\n\n\n\nExercise 5: Compare EPOS and Stairways2\n\n\n\n# EXERCISE:\n# Load the pre-computed Stairways2 result:\n#   Ne_sw &lt;- readRDS(file.path(path.data, \"Ne_sw_gl100.rds\"))\n#\n# Run EPOS on the same dataset (gl100, L = 5e8, mu = 1e-8).\n# Plot both trajectories on the same graph for direct comparison.\n#\n# HINT: Stairways2 returns \"year\" on the x-axis; EPOS returns \"generation\".\n# If generation time = 1 year they are equivalent.\n#\n# QUESTIONS:\n# - Do EPOS and Stairways2 agree on the general trajectory?\n# - Do the confidence intervals differ in width?\n# - In what circumstances would you prefer Stairways2 over EPOS?\n\ngl100 &lt;- readRDS(file.path(path.data, \"slim_100.rds\"))\nNe_sw &lt;- readRDS(file.path(path.data, \"Ne_sw_gl100.rds\"))\n\nL  &lt;- 5e8\nmu &lt;- 1e-8\n\n# Your code here:",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Effective Population Size</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W07/W07.html#additional-exercises",
    "href": "inst/tutorials/W07/W07.html#additional-exercises",
    "title": "7  Effective Population Size",
    "section": "Additional Exercises",
    "text": "Additional Exercises\n\nExercise A: Apply the full LD Ne workflow to a real dataset\n\n\n\n# EXERCISE:\n# Using possums.gl, choose two populations of contrasting size or history.\n# Run the full LD Ne workflow:\n#   1. gl.keep.pop() to keep each population separately\n#   2. gl.LDNe() with critical = c(0, 0.05)\n# Compare the Ne estimates for the two populations.\n#\n# QUESTIONS:\n# - Which population has the lower Ne?\n# - What does a low Ne imply for conservation management of that population?\n# - Do the Ne estimates change notably between critical = 0 and critical = 0.05?\n\ndir_ne &lt;- gl.download.binary(\"neestimator\", out.dir = tempdir())\n\n# Your code here:\n\n\n\n\n\n\n\nExercise B: Estimating L from Watterson’s estimator\n\n\n\n# EXERCISE:\n# When L is unknown, it can be estimated from Watterson's theta.\n# The formula is:\n#   L = sum(sfs[-1]) / (4 * n * mu * a_n)\n# where a_n = sum(1/i for i = 1 to 2n-1) is the Watterson normalisation constant,\n# n is the number of individuals, and mu is the mutation rate.\n#\n# Use this formula to estimate L for the sim50 dataset (true L = 5e8),\n# then run EPOS with L_est and compare to the result with the true L.\n\nsim50 &lt;- gl.sim.Neconst(ninds = 50, nlocs = 3000)\nfor (i in 1:5) sim50 &lt;- gl.sim.offspring(sim50, sim50, noffpermother = 1)\n\nmu &lt;- 1e-8\nn  &lt;- nInd(sim50)\n\nsfs &lt;- gl.sfs(sim50)\n\n# Watterson normalisation constant\na_n &lt;- sum(1 / (1:(2*n - 1)))\na_n\n\n# Estimate L using Watterson's formula\nL_est &lt;- sum(sfs[-1]) / (4 * n * mu * a_n)\nL_est  # how close is this to the true L = 5e8?\n\n# Now run EPOS with L_est and compare to the true-L run\n# dir_epos &lt;- gl.download.binary(\"epos\", out.dir = tempdir())\n# Ne_est  &lt;- gl.run.epos(sim50, epos.path = dir_epos, L = L_est,   u = mu, boot = 10)\n# Ne_true &lt;- gl.run.epos(sim50, epos.path = dir_epos, L = 5e8,     u = mu, boot = 10)\n\n# QUESTIONS:\n# - How accurate is the Watterson estimate of L?\n# - How much does the resulting Ne trajectory differ between L_est and the true L?",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Effective Population Size</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W07/W07.html#winding-up",
    "href": "inst/tutorials/W07/W07.html#winding-up",
    "title": "7  Effective Population Size",
    "section": "Winding Up",
    "text": "Winding Up\n\nDiscussion Questions\n\nYou have a threatened frog species with Nc = 2000 adults and an LD Ne estimate of 80. What does the large Nc/Ne ratio imply about the species’ biology? What management actions might you consider?\nA coalescent Ne analysis shows a wolf population had Ne ~ 10,000 during the Pleistocene, declining to ~500 in the last 200 years. An LD Ne estimate from current samples gives Ne = 40. Are these estimates contradictory? What is each capturing?\nYou run EPOS on two populations of the same species. Both show similar trajectory shapes but the axis values differ by a factor of three. Before concluding the populations have genuinely different histories, what alternative explanations should you rule out?\nWhy might singletons be removed (minbinsize = 2 or higher) in empirical SFS-based analyses of real data? What biological information do you lose by removing them?\nA colleague argues that Stairways2 is always preferable to EPOS because it uses a more sophisticated optimisation. When would you disagree, and why?\n\n\n\nWhere Have We Come?\nIn this session we have covered:\n\nThe definition of Ne and why Ne &lt; Nc in real populations — and why this matters for conservation\nThe three major classes of Ne estimator: drift Ne, LD Ne, and coalescent Ne, each measuring the same underlying concept at different timescales\nThe LD-based contemporary Ne using gl.LDNe, with emphasis on MAF filtering (critical), the Waples correction for genomic data, and the interpretation of Inf estimates\nThe Site Frequency Spectrum (SFS): what it is, how to compute it with gl.sfs, and what demographic signals its shape contains\nHistorical Ne inference using EPOS — fast and practical for exploratory work — including the critical role of L and mu in determining absolute versus relative trajectory estimates\nThe relationship between EPOS and Stairways2, and when each is appropriate",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Effective Population Size</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W07/W07.html#further-reading",
    "href": "inst/tutorials/W07/W07.html#further-reading",
    "title": "7  Effective Population Size",
    "section": "Further Reading",
    "text": "Further Reading\n\nFranklin, I. R. (1980). Evolutionary change in small populations. In: Soule, M. E. & Wilcox, B. A. (eds) Conservation Biology: An Evolutionary-Ecological Perspective. Sinauer, Sunderland.\nWaples, R. S. (2006). A bias correction for estimates of effective population size based on linkage disequilibrium at unlinked gene loci. Conservation Genetics 7: 167–184.\nWaples, R. K. et al. (2016). Estimating contemporary effective population size in non-model species using linkage disequilibrium across thousands of loci. Heredity 117: 233–240.\nLynch, M. et al. (2019). Inference of historical population-size changes with allele-frequency data. G3: Genes, Genomes, Genetics 9: 2501–2512. [EPOS]\nLiu, X. & Fu, Y.-X. (2020). Stairway Plot 2: demographic history inference with folded SNP frequency spectra. Genome Biology 21: 280. [Stairways2]\nFrankham, R. (1995). Effective population size/adult population size ratios in wildlife: a review. Genetics Research 66: 95–107.\nHoban, S. et al. (2022). Global genetic diversity status and trends: towards a suite of essential biodiversity variables (EBVs) for genetic composition. Biological Reviews 97: 1511–1538.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Effective Population Size</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W08/W08.html",
    "href": "inst/tutorials/W08/W08.html",
    "title": "8  W08 Divergence & Phylogenetics",
    "section": "",
    "text": "W08 Genetic Divergence & Phylogenetics",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>W08 Divergence & Phylogenetics</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W08/W08.html#introduction",
    "href": "inst/tutorials/W08/W08.html#introduction",
    "title": "8  W08 Divergence & Phylogenetics",
    "section": "Introduction",
    "text": "Introduction\n\nLearning outcomes\nWhat is the goal of this session? What will participants learn?\n\n\nPrerquisites\nWhat prior knowledge do they need?\n\n\nWorkflow\nWhat is the structure of the session?\n\n\nAdditional reading\nAnything else you want to add?",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>W08 Divergence & Phylogenetics</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W08/W08.html#topic",
    "href": "inst/tutorials/W08/W08.html#topic",
    "title": "8  W08 Divergence & Phylogenetics",
    "section": "Topic",
    "text": "Topic\nBrief recap of the topic, relating back to the presentation.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>W08 Divergence & Phylogenetics</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W08/W08.html#worked-ex",
    "href": "inst/tutorials/W08/W08.html#worked-ex",
    "title": "8  W08 Divergence & Phylogenetics",
    "section": "Worked Ex:",
    "text": "Worked Ex:\nWorked example that everyone steps through together - simple example applying the methods\n\n# We show them the code to run",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>W08 Divergence & Phylogenetics</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W08/W08.html#exercises",
    "href": "inst/tutorials/W08/W08.html#exercises",
    "title": "8  W08 Divergence & Phylogenetics",
    "section": "Exercises",
    "text": "Exercises\nExercises where they can use their own data or supplied data to try out what they have learnt in a new context.\n\ndot points\nfor different steps",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>W08 Divergence & Phylogenetics</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W08/W08.html#winding-up",
    "href": "inst/tutorials/W08/W08.html#winding-up",
    "title": "8  W08 Divergence & Phylogenetics",
    "section": "Winding up",
    "text": "Winding up\n\nDiscussion Time\nAdd some questions to help group discussion.\n\n\nWhere have we come?\nSummarise what they should have learnt.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>W08 Divergence & Phylogenetics</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W09/W09.html",
    "href": "inst/tutorials/W09/W09.html",
    "title": "9  W09 dartR developer",
    "section": "",
    "text": "W09 dartR developer",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>W09 dartR developer</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W09/W09.html#introduction",
    "href": "inst/tutorials/W09/W09.html#introduction",
    "title": "9  W09 dartR developer",
    "section": "Introduction",
    "text": "Introduction\n\nLearning outcomes\nWhat is the goal of this session? What will participants learn?\n\n\nPrerquisites\nWhat prior knowledge do they need?\n\n\nWorkflow\nWhat is the structure of the session?\n\n\nAdditional reading\nAnything else you want to add?",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>W09 dartR developer</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W09/W09.html#topic",
    "href": "inst/tutorials/W09/W09.html#topic",
    "title": "9  W09 dartR developer",
    "section": "Topic",
    "text": "Topic\nBrief recap of the topic, relating back to the presentation.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>W09 dartR developer</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W09/W09.html#worked-ex",
    "href": "inst/tutorials/W09/W09.html#worked-ex",
    "title": "9  W09 dartR developer",
    "section": "Worked Ex:",
    "text": "Worked Ex:\nWorked example that everyone steps through together - simple example applying the methods\n\n# We show them the code to run",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>W09 dartR developer</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W09/W09.html#exercises",
    "href": "inst/tutorials/W09/W09.html#exercises",
    "title": "9  W09 dartR developer",
    "section": "Exercises",
    "text": "Exercises\nExercises where they can use their own data or supplied data to try out what they have learnt in a new context.\n\ndot points\nfor different steps",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>W09 dartR developer</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W09/W09.html#winding-up",
    "href": "inst/tutorials/W09/W09.html#winding-up",
    "title": "9  W09 dartR developer",
    "section": "Winding up",
    "text": "Winding up\n\nDiscussion Time\nAdd some questions to help group discussion.\n\n\nWhere have we come?\nSummarise what they should have learnt.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>W09 dartR developer</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W10/W10.html",
    "href": "inst/tutorials/W10/W10.html",
    "title": "10  W10 Natural Selection & Adaptation",
    "section": "",
    "text": "W10 Natural Selection & Adaptation",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>W10 Natural Selection & Adaptation</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W10/W10.html#introduction",
    "href": "inst/tutorials/W10/W10.html#introduction",
    "title": "10  W10 Natural Selection & Adaptation",
    "section": "Introduction",
    "text": "Introduction\n\nLearning outcomes\nWhat is the goal of this session? What will participants learn?\n\n\nPrerquisites\nWhat prior knowledge do they need?\n\n\nWorkflow\nWhat is the structure of the session?\n\n\nAdditional reading\nAnything else you want to add?",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>W10 Natural Selection & Adaptation</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W10/W10.html#topic",
    "href": "inst/tutorials/W10/W10.html#topic",
    "title": "10  W10 Natural Selection & Adaptation",
    "section": "Topic",
    "text": "Topic\nBrief recap of the topic, relating back to the presentation.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>W10 Natural Selection & Adaptation</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W10/W10.html#worked-ex",
    "href": "inst/tutorials/W10/W10.html#worked-ex",
    "title": "10  W10 Natural Selection & Adaptation",
    "section": "Worked Ex:",
    "text": "Worked Ex:\nWorked example that everyone steps through together - simple example applying the methods\n\n# We show them the code to run",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>W10 Natural Selection & Adaptation</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W10/W10.html#exercises",
    "href": "inst/tutorials/W10/W10.html#exercises",
    "title": "10  W10 Natural Selection & Adaptation",
    "section": "Exercises",
    "text": "Exercises\nExercises where they can use their own data or supplied data to try out what they have learnt in a new context.\n\ndot points\nfor different steps",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>W10 Natural Selection & Adaptation</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W10/W10.html#winding-up",
    "href": "inst/tutorials/W10/W10.html#winding-up",
    "title": "10  W10 Natural Selection & Adaptation",
    "section": "Winding up",
    "text": "Winding up\n\nDiscussion Time\nAdd some questions to help group discussion.\n\n\nWhere have we come?\nSummarise what they should have learnt.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>W10 Natural Selection & Adaptation</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W11/W11.html",
    "href": "inst/tutorials/W11/W11.html",
    "title": "11  W11 Landscape Genetics",
    "section": "",
    "text": "W11 Landscape genetics",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>W11 Landscape Genetics</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W11/W11.html#introduction",
    "href": "inst/tutorials/W11/W11.html#introduction",
    "title": "11  W11 Landscape Genetics",
    "section": "Introduction",
    "text": "Introduction\n\nLearning outcomes\nWhat is the goal of this session? What will participants learn?\n\n\nPrerquisites\nWhat prior knowledge do they need?\n\n\nWorkflow\nWhat is the structure of the session?\n\n\nAdditional reading\nAnything else you want to add?",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>W11 Landscape Genetics</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W11/W11.html#topic",
    "href": "inst/tutorials/W11/W11.html#topic",
    "title": "11  W11 Landscape Genetics",
    "section": "Topic",
    "text": "Topic\nBrief recap of the topic, relating back to the presentation.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>W11 Landscape Genetics</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W11/W11.html#worked-ex",
    "href": "inst/tutorials/W11/W11.html#worked-ex",
    "title": "11  W11 Landscape Genetics",
    "section": "Worked Ex:",
    "text": "Worked Ex:\nWorked example that everyone steps through together - simple example applying the methods\n\n# We show them the code to run",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>W11 Landscape Genetics</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W11/W11.html#exercises",
    "href": "inst/tutorials/W11/W11.html#exercises",
    "title": "11  W11 Landscape Genetics",
    "section": "Exercises",
    "text": "Exercises\nExercises where they can use their own data or supplied data to try out what they have learnt in a new context.\n\ndot points\nfor different steps",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>W11 Landscape Genetics</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W11/W11.html#winding-up",
    "href": "inst/tutorials/W11/W11.html#winding-up",
    "title": "11  W11 Landscape Genetics",
    "section": "Winding up",
    "text": "Winding up\n\nDiscussion Time\nAdd some questions to help group discussion.\n\n\nWhere have we come?\nSummarise what they should have learnt.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>W11 Landscape Genetics</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W12/W12.html",
    "href": "inst/tutorials/W12/W12.html",
    "title": "12  W12 AI in PopGen & Research",
    "section": "",
    "text": "W12 AI in PopGen & Research",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>W12 AI in PopGen & Research</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W12/W12.html#introduction",
    "href": "inst/tutorials/W12/W12.html#introduction",
    "title": "12  W12 AI in PopGen & Research",
    "section": "Introduction",
    "text": "Introduction\n\nLearning outcomes\nWhat is the goal of this session? What will participants learn?\n\n\nPrerquisites\nWhat prior knowledge do they need?\n\n\nWorkflow\nWhat is the structure of the session?\n\n\nAdditional reading\nAnything else you want to add?",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>W12 AI in PopGen & Research</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W12/W12.html#topic",
    "href": "inst/tutorials/W12/W12.html#topic",
    "title": "12  W12 AI in PopGen & Research",
    "section": "Topic",
    "text": "Topic\nBrief recap of the topic, relating back to the presentation.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>W12 AI in PopGen & Research</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W12/W12.html#worked-ex",
    "href": "inst/tutorials/W12/W12.html#worked-ex",
    "title": "12  W12 AI in PopGen & Research",
    "section": "Worked Ex:",
    "text": "Worked Ex:\nWorked example that everyone steps through together - simple example applying the methods\n\n# We show them the code to run",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>W12 AI in PopGen & Research</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W12/W12.html#exercises",
    "href": "inst/tutorials/W12/W12.html#exercises",
    "title": "12  W12 AI in PopGen & Research",
    "section": "Exercises",
    "text": "Exercises\nExercises where they can use their own data or supplied data to try out what they have learnt in a new context.\n\ndot points\nfor different steps",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>W12 AI in PopGen & Research</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W12/W12.html#winding-up",
    "href": "inst/tutorials/W12/W12.html#winding-up",
    "title": "12  W12 AI in PopGen & Research",
    "section": "Winding up",
    "text": "Winding up\n\nDiscussion Time\nAdd some questions to help group discussion.\n\n\nWhere have we come?\nSummarise what they should have learnt.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>W12 AI in PopGen & Research</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W13/W13.html",
    "href": "inst/tutorials/W13/W13.html",
    "title": "13  W13 Simulations",
    "section": "",
    "text": "W13 Simulations for Conservation Genetics\nSession Presenters\nand Luis",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>W13 Simulations</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W13/W13.html#learning-outcomes",
    "href": "inst/tutorials/W13/W13.html#learning-outcomes",
    "title": "13  W13 Simulations",
    "section": "Learning outcomes",
    "text": "Learning outcomes\nIn this session we will learn how to run simulations within the dartRverse. We will start with very simple simulations and then add complexity to them. By the end of the session you should be able to run simple simulations of genetic drift, population divergence, and demographic processes using dartR functions, and understand how to interpret the results in a conservation context.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>W13 Simulations</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W13/W13.html#introduction",
    "href": "inst/tutorials/W13/W13.html#introduction",
    "title": "13  W13 Simulations",
    "section": "Introduction",
    "text": "Introduction\n\nUsing simulations in the dartRverse for conservation genetics\nSimulation is one of the most powerful yet underused tools in conservation genetics. While empirical SNP datasets tell us what has happened, simulations allow us to ask what could happen under alternative management scenarios—and to do so quickly, transparently, and reproducibly. Within the dartRverse, simulations are designed as lightweight, modular building blocks that integrate naturally with SNP-based analyses used in applied conservation genetics.\nAt its core, the dartRverse simulation framework is not intended to compete with full forward-time population genetic simulators. Instead, it aims to provide rapid, interpretable simulations that allow conservation practitioners and researchers to explore genetic consequences of simplified demographic and management scenarios using the same data structures and summary statistics they already use for real populations.\n\n\nWhy simulate in a conservation context?\nMany conservation questions are fundamentally dynamic:\n\nHow quickly will a small population lose genetic variation through drift?\nHow many generations does it take to lose 50% of heterozygosity under a given effective population size?\nHow effective is supplementation or translocation at preserving allelic diversity?\nHow fast do populations diverge when connectivity is reduced?\nHow do metapopulation dynamics influence genetic differentiation, inbreeding, or genetic rescue outcomes?\n\nSimulations allow these questions to be explored explicitly, often with simple assumptions, before committing to costly or irreversible management actions.\n\n\n\nA modular, “lego-style” simulation philosophy\nThe dartRverse approaches simulations as a sequence of simple, composable processes. Rather than defining an entire demographic model upfront, users build scenarios by chaining together a small number of intuitive functions—much like assembling lego pieces.\nAt a conceptual level, simulations revolve around four core processes:\n\n1. Population creation\nPopulations can be generated de novo or derived directly from empirical SNP datasets. This allows simulations to begin from realistic allele frequencies, levels of heterozygosity, and population structure, rather than abstract starting conditions.\n\n\n2. Drift and mutation\nAllele frequencies change over generations due to genetic drift, with optional mutation. Even under extremely simple population dynamics, this immediately illustrates how small effective population sizes rapidly erode genetic diversity—often far faster than expected.\n\n\n3. Survival and migration\nIndividuals can survive, be removed, or migrate between populations. This enables exploration of connectivity, fragmentation, and metapopulation dynamics without invoking complex spatially explicit models.\n\n\n4. Reproduction\nReproduction can be modelled through simple cloning or sexual reproduction, allowing users to explore consequences for heterozygosity, inbreeding, and relatedness under different mating systems.\nEach step produces SNP data in familiar dartR objects, making it trivial to calculate standard diversity metrics at any point in the simulation.\n\n\n\n\nBuilding complexity incrementally\nA key strength of this approach is that complex dynamics emerge from simple rules. By combining basic processes, users can rapidly construct realistic conservation scenarios, such as:\n\nPeriodic supplementation (e.g. adding individuals every five generations)\nFounder events followed by isolation\nAsymmetric migration between source and sink populations\nTemporary corridors that restore gene flow for limited time periods\n\nBecause simulations are embedded in R, users can easily extend them further—for example by introducing sex- or age-dependent survival, stochastic catastrophes, or spatial structure linked to resistance surfaces and home ranges.\n\n\n\nTypical conservation genetics use cases\nSome common applications of dartRverse simulations include:\n\nGenetic drift over time\nTracking loss of heterozygosity or allelic richness across generations under different effective population sizes.\nSupplementation and genetic rescue\nEvaluating how many individuals are required, and how often, to maintain genetic diversity or slow inbreeding.\nMetapopulation dynamics\nExploring how migration rates influence differentiation, extinction–recolonisation dynamics, and long-term persistence.\nTemporal change in population structure\nMonitoring trajectories of population differentiation, relatedness, or inbreeding coefficients as populations diverge or reconnect.\n\nBecause simulated datasets are analysed using the same summary statistics as empirical SNP data, results are immediately interpretable and directly comparable to real monitoring data.\n\n\n\nFrom exploration to decision support\nUltimately, simulations in the dartRverse allow conservation geneticists to test assumptions, visualise outcomes, and communicate genetic risks and benefits to managers and stakeholders. Even highly simplified simulations can provide powerful insights into how quickly genetic diversity can be lost—and how strategic interventions can slow, or even reverse, that loss. In this way, simulations become not just a teaching tool, but a practical component of evidence-based conservation decision-making.\nPlease be aware dartRverse is not a fully fledged simulation tool. It allows to do quick and easy simulations, but for a comprehensive simulation framework you should consider using SLIM. By the way there is a cool package called ‘slimR’ which allows to integrate and run simulations from within R (and it talk to the dartRverse for analysis).",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>W13 Simulations</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W13/W13.html#prerequisites-and-background-knowledge",
    "href": "inst/tutorials/W13/W13.html#prerequisites-and-background-knowledge",
    "title": "13  W13 Simulations",
    "section": "Prerequisites and background knowledge",
    "text": "Prerequisites and background knowledge\nSimulations in the dartRverse can range from very simple to highly complex. At the simplest level, many conservation scenarios can be explored using built-in dartRverse functions with minimal coding, making simulations accessible to users with basic R skills. More advanced applications, however, require custom workflows written directly in R, where dartRverse functions are combined with user-defined logic to represent realistic demographic, genetic, or management processes.\nAs a result, a working knowledge of R programming and familiarity with dartR data objects (e.g. genlight, `dartR’ and related structures) is essential. Simulations often require small but important data transformations, such as subsetting populations, updating metadata, reshaping outputs, or tracking summary statistics across generations. When individual simulation runs become computationally intensive—particularly when stochasticity is important—it is common to repeat simulations hundreds or thousands of times. In these cases, parallelisation (using standard R tools) becomes critical for keeping runtimes practical.\nFinally, simulations are only as informative as the questions they are designed to address. Users therefore need a solid understanding of population genetic concepts and appropriate metrics for quantifying genetic change. This includes knowing when to track heterozygosity, allelic richness, inbreeding, or population differentiation, and how these measures relate to processes such as drift, migration, and supplementation. Thoughtful choice of summary statistics is key to translating simulation outputs into meaningful conservation insights.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>W13 Simulations</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W13/W13.html#session-overview",
    "href": "inst/tutorials/W13/W13.html#session-overview",
    "title": "13  W13 Simulations",
    "section": "Session overview",
    "text": "Session overview\nThis session introduces simulations in the dartRverse using a step-by-step complexity approach. We begin with very simple simulations and progressively add biological and demographic realism.\n\nSim 1: A simple simulation\n\nCreate a population from existing SNP data\nSimulate genetic drift over generations\nTrack simple diversity metrics (e.g. heterozygosity over time)\n\nSim 2: Replication and uncertainty\n\nRepeat simulations to capture stochasticity\nVisualise variability among simulation runs\nInterpret expected vs realised genetic trajectories\n\nSim 3: Population divergence\n\nSimulate multiple isolated populations\nExplore how genetic differentiation (e.g. FST) increases over time\nIntroduce migration to illustrate connectivity effects\n\nSim 4: Demography and reproduction\n\nAdd survival and reproduction processes\nExplore population size limits and allele loss\nLink demographic parameters to genetic outcomes\n\nSim 5: Applied conservation questions\n\nSupplementation and genetic rescue scenarios\nMetapopulation dynamics\nPerformance of SNP panels through time\n\nWrap-up\n\nKey insights from simple vs complex simulations\nWhen dartRverse simulations are sufficient\nWhen to move to more detailed forward simulators",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>W13 Simulations</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W13/W13.html#setup",
    "href": "inst/tutorials/W13/W13.html#setup",
    "title": "13  W13 Simulations",
    "section": "Setup",
    "text": "Setup\nTo setup the session, we need to load the necessary libraries. The main one is dartRverse which contains all the functions we will use for simulations and analysis. We also load ggplot2 and tidyr for data manipulation and visualization. Make sure you have these packages installed and loaded before proceeding with the tutorial and also make sure the dartRverse package is up to date, as the simulation functions are relatively new and may have been updated since the last release.\n\nlibrary(dartRverse)\nlibrary(ggplot2)\nlibrary(tidyr)",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>W13 Simulations</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W13/W13.html#tutorial",
    "href": "inst/tutorials/W13/W13.html#tutorial",
    "title": "13  W13 Simulations",
    "section": "Tutorial",
    "text": "Tutorial",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>W13 Simulations</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W13/W13.html#sim-1-a-simple-simulation",
    "href": "inst/tutorials/W13/W13.html#sim-1-a-simple-simulation",
    "title": "13  W13 Simulations",
    "section": "Sim 1: A simple simulation",
    "text": "Sim 1: A simple simulation\nThe dartRverse allows to run time forward simulations. Often you want to run some simulation based on an existing genlight object.\nWe load some example data\n\nrfbe &lt;- readRDS(\"./data/rfbe.rds\")\n\nand then run the gl.report.basics function to check its content. Have a look at the output and feel free to explore the dataset further using other functions. You can for example check the the amount of missing data or the number of individuals in each population.\n\n\n\ngl.report.basics(rfbe)\n\n\n\n\nThe next step is to think about a simulation scenario. Here we come up with a very simple one:\n\n\n\n\n\n\nNoneScenario\n\n\n\nA new population is founded by translocating ten individuals from one of the populations in the data set (PJTub1.2.3). The population evolves for 15 generations under a drift-only Wright–Fisher process with no sexual reproduction, no mutation, and no additional releases, allowing us to examine the loss of heterozygosity through time.\n\n\nSo lets create a new population from the existing one by subsetting the dartR object and then subsample 10 individuals from it.\n\n# copy only the source population int a new dartR object\nsource &lt;- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\")\n\nStarting gl.keep.pop \n  Processing genlight object with SNP data\n  Checking for presence of nominated populations\n  Retaining only populations PJTub1.2.3 \n  Warning: Resultant dataset may contain monomorphic loci\n  Locus metrics not recalculated\nCompleted: gl.keep.pop \n\n\nNext, we inspect the source population to determine the number of individuals and the extent of missing data.\n\n\n\n### number of individuals in the source population\n\n### missing data in the genotypes of the source population\n\n\n\n\nAs you can see there is missing data in the source population.\nMissing genotypes are generally undesirable in simulations, as they require explicit assumptions about how missing alleles are handled during reproduction. To avoid introducing additional complexity at this stage, we remove loci with missing data by filtering (an alternative approach would be genotype imputation). In most simulation studies, it is preferable to work with complete datasets; however, there are situations where the effects of missing data are themselves of interest, in which case an explicit strategy for handling missingness is required.\n\n#remove missing data using a strict callrate filter\nsource2 &lt;- gl.filter.callrate(source, method=\"loc\", threshold=1)\n\n\n\n\n#check if there are no missing data in the genotypes of source2\n\n\n\n\nThe next step is to create a new population of 10 individuals using the source2 population\n\n# create a new population of 10 individuals using individuals from source2  \nset.seed(7)\nnewpop &lt;- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\n\n\n\n#check number of individuals and missing data in newpop\n\n\n\n\nAs we want to observe the change in heterozygosity we calculate heterozygosity for this populuation\n\n\n\n#find a way to calculate the mean heterozygosity of the new population\n\n\n\n\nThe next step is then repeat this for 15 generations (assuming an ideal poulation for simplicity)\n\n#we create a vector that holds heterozygosity over generation\nres &lt;- NA\n#He of Generation 1\nres[1] &lt;- mean(gl.He(newpop))\n\nfor (gen in 2:15)\n{\n  #ideal popluation = cloning snails\n  newpop &lt;- gl.sim.ind(newpop, n=10)\n  \n  #He of generation gen\n  res[gen] &lt;- mean(gl.He(newpop))\n  cat(\"Generation\", gen, \"Heterozygosity:\", res[gen], \"\\n\")\n  flush.console()\n}\n\nGeneration 2 Heterozygosity: 0.2139878 \nGeneration 3 Heterozygosity: 0.2027301 \nGeneration 4 Heterozygosity: 0.1927387 \nGeneration 5 Heterozygosity: 0.1830851 \nGeneration 6 Heterozygosity: 0.1740539 \nGeneration 7 Heterozygosity: 0.1661645 \nGeneration 8 Heterozygosity: 0.1572521 \nGeneration 9 Heterozygosity: 0.1494537 \nGeneration 10 Heterozygosity: 0.1424043 \nGeneration 11 Heterozygosity: 0.1350277 \nGeneration 12 Heterozygosity: 0.1285154 \nGeneration 13 Heterozygosity: 0.1214895 \nGeneration 14 Heterozygosity: 0.1161175 \nGeneration 15 Heterozygosity: 0.1101693 \n\n#Create a plot\nplot(res, type=\"b\", xlab=\"Generation\", ylab=\"Expected heterozygosity\", \n     main=\"Simulation of expected heterozygosity over time\")\n\n\n\n\n\n\n\n\nYou can now change setting and play with the simulation. For example increase the number of generations or the number of initial founding individuals. You need to run the golden chunks in order to make sure all the objects are updated.\nHere is the full simulation in one code block. Change to your liking. Eg. run more generations, or how does the simulation change if you sample from less/more individuals from the source, change the source population. Monitor observerd heterozygosity instead of experced.\n\n\n\nrfbe &lt;- readRDS(\"./data/rfbe.rds\")\nsource &lt;- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose=0)\nsource2 &lt;- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop &lt;- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\nres&lt;-NA\nres[1] &lt;- mean(gl.He(newpop))\n\nfor (gen in 2:15)\n{\n  #ideal popluation = cloning snails\n  newpop &lt;- gl.sim.ind(newpop, n=10)\n  #He of generation gen\n  res[gen] &lt;- mean(gl.He(newpop))\n}\n\nplot(res, type=\"b\", xlab=\"Generation\", ylab=\"Expected heterozygosity\", \n     main=\"Simulation of expected heterozygosity over time\")\n\n\n\n\nThis is a very simple simulation, but it shows the basic idea. You can also use the gl.sim.offspring function to simulate more complex scenarios, such as different mating systems and check the effect.\nThis was only one instance so we can repeat this simulation 10 times to get a better estimate of the expected heterozygosity over time. To do so we first create a function around the whole simulation (which makes life easier for repeats), as this will allow us to run the simulation in parallel using the parallel package.\n\nsimHe &lt;- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer &lt;- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res &lt;- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer &lt;- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] &lt;- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\nNow we run the simulation by a simple call to the function. You can change the number of generations and the number of individuals in the founding population to see how it affects the expected heterozygosity over time.\n\n\n\n#test the function\nout &lt;- simHe(source2, nInd = 30, ngens = 20)\nplot(out, type=\"b\", xlab=\"Generation\", ylab=\"Expected heterozygosity\",\n     main=\"Simulation of expected heterozygosity over time\")\n\n\n\n\n\n\n\n\n\n\n\nThe step to parallelise them is straightforward. We can use the future package to run the simulations in parallel. This is especially useful when we want to run a large number of simulations (e.g., 100 or more) to capture the stochasticity of the process.\n\n\n\nlibrary(future.apply)\nplan(multisession, workers=3) # or plan(multicore) on Unix-like systems\nn_sims &lt;- 9\nsim_results &lt;- future_lapply(1:n_sims, function(i) {\n  simHe(source2, nInd = 30, ngens = 20)},  future.seed=TRUE)\n\n#create a plot\noutmat &lt;- data.frame(do.call(cbind, sim_results))\nmatplot(outmat, type=\"b\", xlab=\"Generation\", ylab=\"Expected heterozygosity\",\n        main=\"Simulation of expected heterozygosity over time\", col=1:n_sims, pch=1:n_sims)\n\n\n\n\n\n\n\n\n\n\nNoneExercise\n\n\n\nCreate a simulation of expected heterozygosity over time for the source population PJTub1.2.3, but this time transfer only 5 individuals and run the simulation for 50 generations. Repeat the simulation 5 times and plot the results using a boxplot. Or find another scenario you want to simulate. You can also change the gl.sim.offspring function to simulate more complex scenarios, such as different mating systems and check the effect.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>W13 Simulations</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W13/W13.html#sim-2-starting-conditions-for-simulations",
    "href": "inst/tutorials/W13/W13.html#sim-2-starting-conditions-for-simulations",
    "title": "13  W13 Simulations",
    "section": "Sim 2: Starting conditions for simulations",
    "text": "Sim 2: Starting conditions for simulations\nSo far, we simulated a very simple drift-only Wright–Fisher process by repeatedly calling gl.sim.ind(). gl.sim.ind() calculates for each loci allele frequencies and then creates the number of specified inviduals using those allele frequencies (stochastically). It therefore can handle missing data, but the resulting dartR-object will have no missing data.\nIn practice, you often want to (i) scale up an empirical population to a larger starting population, or (ii) generate a starting population under a demographic model.\nTwo useful helper functions are:\n\ngl.sim.ind(): creates individuals based on the current allele frequencies in a genlight/dartR object (good when allele frequencies are well-estimated) and you want to simulate a sampled populations’ fate into the future.\ngl.sim.Neconst(): creates individuals based on a constant Ne and mutation rate (useful as a generic starting point; often followed by additional generations to reach realistic genotype structure). A good way to visualise the allele frequencies is a site-frequency spectrum (SFS) plot, which shows the distribution of allele frequencies across loci. This can help you understand the starting conditions of your simulation and how they might influence the outcomes.\n\n\nA) gl.sim.ind: scaling up a well-sampled population\n\n# (speed) use only 1000 loci\nglsim_scale &lt;- gl.sim.ind(source2[,1:1000], n = 100, popname = \"scaled\")\ngl.smearplot(glsim_scale)\ngl.sfs(glsim_scale)\n\n\n\n\n# EXERCISE:\n# 1) Change n to 50, 200 and compare the smearplots.\n# 2) What happens if you use fewer loci (e.g., 200 loci)?\n\n\n\n\n\n\nB) gl.sim.Neconst: a generic starting population\nThis is often useful when you don’t have a well-sampled source population, but still want to explore “what-if” dynamics. or in the absence of an empirical dataset, or when you want to start with a simple demographic model (e.g., constant Ne and mutation) and then add complexity from there.\n\n# Create a starting population under constant Ne and mutation.\n# Then generate offspring for a few generations using clones\n\nstart_pop &lt;- gl.sim.Neconst(Ne = 500, nloc = 1000, mu = 1e-8, nind = 100, popname = \"Neconst\")\n\ngl.smearplot(start_pop)\ngl.sfs(start_pop)\n\n\n\n\n\n\n\nNoneExercise\n\n\n\nDISCUSSION EXERCISE (no coding required): - When would you prefer gl.sim.ind() over gl.sim.Neconst() as a starting point? - Think: allele frequencies, realism, availability of data.\n\n\n\n\n\n# create starting populations using both gl.sim.ind() and gl.sim.Neconst() and compare their allele frequency spectra (SFS). How do the starting conditions differ, and how might this influence the outcomes of your simulations?\n# simulate drift over time (e.g. looking at heterozygosity)",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>W13 Simulations</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W13/W13.html#sim-3-drift-driven-divergence-between-isolated-populations-fst",
    "href": "inst/tutorials/W13/W13.html#sim-3-drift-driven-divergence-between-isolated-populations-fst",
    "title": "13  W13 Simulations",
    "section": "Sim 3: Drift-driven divergence between isolated populations (Fst)",
    "text": "Sim 3: Drift-driven divergence between isolated populations (Fst)\nTo demonstrate gl.sim.ind() further, we simulate a simple expectation:\n\n\n\n\n\n\nNoneScenario\n\n\n\nWe create two populations from the same founding population. We expect they to be similar, so Fst (a meassure of differentiaton) should be close to zero. If the two population evolve in complete isolation, Fst increases over time (eventually approaching 1 at many loci= Loci are fixed at opposite alleles in each population).\n\n\nWe create two populations of 10 individuals each, then evolve them for 20 generations under drift only, with no exchange.\n\ng1 &lt;- gl.sim.ind(source2[,1:1000], n = 10, popname = \"pop1\")\ng2 &lt;- gl.sim.ind(source2[,1:1000], n = 10, popname = \"pop2\")\nfst_mig &lt;- NA\nfor (i in 1:20) {\n  g1 &lt;- gl.sim.ind(g1, n = 10, popname = \"pop1\")\n  g2 &lt;- gl.sim.ind(g2, n = 10, popname = \"pop2\")\n  \n### migration (exchange of individuals between populations)\n  # for example one individuals both ways\n  # gg &lt;- rbind(g1, g2)\n  # migtable &lt;- matrix(c(0,1,1,0), nrow=2, ncol=2) \n  #  gg &lt;- gl.sim.emigration(gg, emi.table=migtable)\n  #  g1 &lt;- gg[pop=\"pop1\",]\n  #  g2 &lt;- gg[pop=\"pop2\",]\n\n### calculate fst\n  gg &lt;- rbind(g1, g2)\n  fst_mig[i] &lt;- gl.fst.pop(gg, verbose = 0)[2, 1]\n}\nplot(fst_mig, type=\"b\", xlab=\"Generation\", ylab=\"Fst\", main=\"Fst over time\")\n\n\n\n\n\n\n\n\nBelow is the previous example with 2 populations, 10 individuals each and no exchange. Run it and check how Fst changes over time. Then modify the code to add migration (exchange of individuals between populations) and see how Fst changes. You can for example swap 1 individual both ways each generation. Then compare your plot to the no-exchange plot above. What changes and why? To do so, uncomment the code in the migration section and run the code again. You can also change the number of migrants (e.g., swap 2 individuals both ways) and see how it affects Fst. The exchange of individuals between populations is a simple way to simulate migration and its effect on genetic differentiation. The more migrants you exchange, the more gene flow there is between the populations, which tends to reduce Fst and keep the populations genetically similar. To accomplish this exchange we need a bit of r-code. There is a function gl.sim.emigration() which allows to simulate emigration based on a migration table. The migration table is a matrix that specifies the number of migrants moving between populations. For example, if you have two populations and you want to swap one individual both ways, your migration table would look like this:\n\nmatrix(c(0,1,1,0), nrow=2, ncol=2)\n\n     [,1] [,2]\n[1,]    0    1\n[2,]    1    0\n\n\nThe entries on the diagonals would swap individuals within the same population (which we don’t want in this case, so they are set to 0), while the off-diagonal entries specify the number of migrants moving between populations (1 individual from pop1 to pop2 and 1 individual from pop2 to pop1).Migration goes from row to column. so the entry in the second row and first column indicates that one individual migrates from population 1 to population 2, while the entry in the first row and second column indicates that one individual migrates from population 2 to population 1. By applying this migration table to the combined dataset of both populations, you can simulate the effect of migration on genetic differentiation over time. Please note you can also specifiy stochastic migration by using a probabilistic approach, which is also implemented in the gl.sim.emigration() function. Just check ?gl.sim.emigration for more details.\n\n\n\n\n\n\nExercise:\n\nWhat changes if you increase population size?\nWhat happens if you increase the number of migrants?\nRemember there is the “Law” of 1 migrant per generation” which states that one migrant per generation is enough to prevent populations from diverging completely (i.e. Fst approaching 1).\n\\[F_{ST} = \\frac{1}{(4Nm + 1)} \\]\n\nwhere N is the population size and m is the migration rate. This formula gives the expected Fst at equilibrium under a simple island model of migration. You can use this formula to predict the expected Fst for different values of N and m, and compare it to your simulation results.\n\n\n\n\n\n\ng1 &lt;- gl.sim.ind(source2[,1:1000], n = 10, popname = \"pop1\")\ng2 &lt;- gl.sim.ind(source2[,1:1000], n = 10, popname = \"pop2\")\nfst_mig &lt;- NA\nfor (i in 1:20) {\n  g1 &lt;- gl.sim.ind(g1, n = 10, popname = \"pop1\")\n  g2 &lt;- gl.sim.ind(g2, n = 10, popname = \"pop2\")\n  \n### migration (exchange of individuals between populations)\n  # for example one individuals both ways\n  # gg &lt;- rbind(g1, g2)\n  # migtable &lt;- matrix(c(0,1,1,0), nrow=2, ncol=2) \n  #  gg &lt;- gl.sim.emigration(gg, emi.table=migtable)\n  #  g1 &lt;- gg[pop=\"pop1\",]\n  #  g2 &lt;- gg[pop=\"pop2\",]\n\n### calculate fst\n  gg &lt;- rbind(g1, g2)\n  fst_mig[i] &lt;- gl.fst.pop(gg, verbose = 0)[2, 1]\n}\nplot(fst_mig, type=\"b\", xlab=\"Generation\", ylab=\"Fst\", main=\"Fst over time\")",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>W13 Simulations</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W13/W13.html#sim-4-adding-demography-birth-death-carrying-capacity",
    "href": "inst/tutorials/W13/W13.html#sim-4-adding-demography-birth-death-carrying-capacity",
    "title": "13  W13 Simulations",
    "section": "Sim 4: Adding demography (birth, death, carrying capacity)",
    "text": "Sim 4: Adding demography (birth, death, carrying capacity)\nDrift-only simulations are useful as a start, but conservation scenarios often need survival, reproduction, and carrying capacity.\nBelow is a simple individual-based simulation (:\n\nstart from allele frequencies (via gl.sim.ind)\nassign sex\ncreate offspring (via gl.sim.offspring)\napply adult survival\napply carrying capacity (K)\nquantify alleles lost after ngens\n\nWe wrap this into a function so we can explore parameters efficiently.\n\n\n\n\n\n\nNonegl.sim.offspring\n\n\n\nA note to gl.sim.offspring: this function simulates sexual reproduction by randomly pairing mothers and fathers to produce offspring genotypes based on Mendelian inheritance. It takes separate sets of individuals for fathers and mothers, allowing for flexible mating systems (e.g., polygyny, monogamy). The noffpermother parameter specifies how many offspring each mother produces, which can be adjusted to simulate different reproductive rates. By using gl.sim.offspring(), we can easily model the genetic consequences of sexual reproduction in our simulations, including changes in allele frequencies and heterozygosity over time.\nFor example if you specify noffpermother = 3, each mother will produce three offspring, and the function will randomly select fathers for each offspring from the pool of males.\nOur famous hermaphrodite implementation, would state:\n\ngl.sim.offsprings(fathers = pop1, mothers = pop1, noffpermother = 1)\n\nThis would allow each individual to be both a mother and a father, and each individual would produce one offspring on average. This is a simple way to simulate a Wright-Fisher simulation, because every individual can reproduce with any other individual (no sexes) and even reproduce with itself (selfing). This is a common assumption in many population genetics models, and it allows us to focus on the effects of genetic drift without the added complexity of sexual reproduction.\nIf you have another situation of say polygyny, where one male mates with multiple females, you could specify the fathers and mothers separately. For example if you have a “seal-situation” that there is a single dominant male you would specify the fathers as a single individual and the mothers as the rest of the population. For example: the dom\n\ndommale &lt;- gl.keep.ind(gl, ind.list = \"dommmale\")  #we keep track via the individual name\nmothers &lt;- pop1[pop(gl) == \"F\",] #pop has information on male and females\ngl.sim.offsprings(fathers = dommale, mothers = mothers, noffpermother = 3)\n# This would simulate a polygynous mating system where one dominant male\n# we could now check how many of the offsprings will survive etc.\n\n\n\nOkay back to our simulation. We wanted a realistic example of allele loss through time, so we start with a population of 100 individuals and 1000 loci. We then simulate 30 generations of survival and reproduction, with a survival rate of 80% and each mother producing 3 offspring. We also enforce a carrying capacity of 100 individuals to prevent the population from growing indefinitely. After the simulation, we count how many alleles have been lost (i.e., how many loci have become monomorphic) and return that number.\n\nsim_alleles_lost &lt;- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 &lt;- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 &lt;- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) &lt;- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off &lt;- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) &lt;- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep &lt;- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 &lt;- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 &lt;- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) &gt; K) {\n      remove &lt;- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 &lt;- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost \n  # (works because genotypes are coded 0/1/2; allele lost -&gt; mean is exactly 0 or 2)\n  # this is faster than gl.report.nall()\n  alleles_lost &lt;- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\nTest the function on a starting dataset with no monomorphic loci:\n\n\n\nstart &lt;- gl.filter.monomorphs(source2, verbose = 0) #get rid of fixed loci\nout &lt;- sim_alleles_lost(start, ngens = 30, nind = 20, nloc = 1000, surv = 0.8, repro = 3, K = 100)\nout\n\n[1] 218\n\n\n\n\n\n\n\n\n# EXERCISE:\n# Run the same simulation, but change ONE parameter at a time.\n# Try:\n# 1) surv = 0.5 vs 0.9\n# 2) K = 50 vs 200\n# 3) nind = 20 vs 100\n#\n# Record (roughly) how n_alleles changes and explain why.\n\n\n\n\nNow we can run a small parameter sweep. (Note: this can take a little time.)\n\nparas &lt;- expand.grid(\n  ngens = 1:10,\n  ninds = 20,\n  nlocs = 1000,\n  surv  = c(0.5, 0.8, 0.9),\n  repro = 3,\n  K     = 50\n)\n\nres &lt;- sapply(1:nrow(paras), function(i) {\n  sim_alleles_lost(start,\n                   ngens = paras$ngens[i],\n                   nind  = paras$ninds[i],\n                   nloc  = paras$nlocs[i],\n                   surv  = paras$surv[i],\n                   repro = paras$repro[i],\n                   K     = paras$K[i])\n})\n\nparas$alleleslost &lt;- res\n\nggplot(paras, aes(x = ngens, y = alleleslost, group = factor(ninds), color = factor(ninds))) +\n  geom_line() +\n  labs(x = \"Generations\", y = \"Alleles lost\", color = \"Population size\") +\n  facet_wrap(~surv)\n\n\n\n\n\n\n\n\n\n\n\n# EXERCISE:\n# Modify the parameter grid to explore a different question.\n# For example:\n# - let ninds vary (e.g., 20, 50, 100)\n# - keep surv fixed, but vary K\n# - increase ngens to 30 (warning: slower)\n#\n# Then re-run and interpret the plot.\n\nparas &lt;- expand.grid(\n  ngens = 1:10,\n  ninds = 20,\n  nlocs = 1000,\n  surv  = c(0.5, 0.8, 0.9),\n  repro = 3,\n  K     = 50\n)\n\nres &lt;- sapply(1:nrow(paras), function(i) {\n  sim_alleles_lost(start,\n                   ngens = paras$ngens[i],\n                   nind  = paras$ninds[i],\n                   nloc  = paras$nlocs[i],\n                   surv  = paras$surv[i],\n                   repro = paras$repro[i],\n                   K     = paras$K[i])\n})\n\nparas$alleleslost &lt;- res\n\nggplot(paras, aes(x = ngens, y = alleleslost, group = factor(ninds), color = factor(ninds))) +\n  geom_line() +\n  labs(x = \"Generations\", y = \"Alleles lost\", color = \"Population size\") +\n  facet_wrap(~surv)",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>W13 Simulations</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W13/W13.html#sim-5-snp-panel-performance-through-time",
    "href": "inst/tutorials/W13/W13.html#sim-5-snp-panel-performance-through-time",
    "title": "13  W13 Simulations",
    "section": "Sim 5: SNP panel performance through time",
    "text": "Sim 5: SNP panel performance through time\nWe learned how to select SNP panels — but how well do panels behave through time as populations drift?\nHere we: 1) subset some populations from the RFBE dataset,\n2) impute missing data,\n3) build a SNP panel (fast example: method=\"pic\"),\n4) simulate forward and track panel performance over generations using the \\(R^2\\) statistic.\n\n5.1 Build and evaluate a panel at time 0\n\n# keep the first 9 populations (example)\npops &lt;- popNames(rfbe)[1:9]\nrfbe2 &lt;- gl.keep.pop(rfbe, pop.list = pops, verbose = 0)\n\n# impute missing data\nrfbe3 &lt;- gl.impute(rfbe2, method = \"neighbour\")\n\n# build panel (50 loci) and evaluate\npanel &lt;- gl.select.panel(rfbe3, method = \"pic\", nl = 50, verbose = 0)\n\nres0 &lt;- gl.check.panel(panel, rfbe3, parameter = \"Fst\")\nr2_0 &lt;- summary(lm(res0[,1] ~ res0[,2]))$r.squared\nr2_0\n\n\n\n\n# EXERCISE:\n# Change panel size to nl = 25 and nl = 200.\n# Does r2_0 increase? What do you expect and why?\n\n\n\n\n\n\n5.2 Simulate forward and check panel performance over time\nWe simulate each population forward independently (panmictic within-pop, no exchange among pops), then check how well the panel still predicts genome-wide Fst.\n\nxx &lt;- rfbe3\nxx &lt;- xx[order(pop(xx)),]\n\nout &lt;- rep(NA, 10)\nout[1] &lt;- r2_0\n\nfor (g in 2:10) {\n  pops_list &lt;- seppop(xx)\n\n  pops_list &lt;- lapply(pops_list, function(yy) {\n    # simulate offspring within each population\n    dummy &lt;- gl.sim.offspring(yy, yy, noffpermother = 3)\n\n    # keep population size constant by resampling\n    dummy &lt;- gl.sample(dummy, nInd(yy), replace = FALSE, verbose = 0)\n    return(dummy)\n  })\n\n  pops_next &lt;- do.call(rbind, pops_list)\n  pop(pops_next) &lt;- pop(xx)\n\n  res &lt;- gl.check.panel(panel, pops_next, parameter = \"Fst\")\n  out[g] &lt;- summary(lm(res[,1] ~ res[,2]))$r.squared\n\n  xx &lt;- pops_next\n\n  cat(paste(\"Generation\", g, \"R-squared:\", out[g], \"\n\"))\n  flush.console()\n}\n\nplot(out, type=\"b\", xlab=\"Generation\", ylab=\"R-squared\", \n     main=\"Performance of SNP panel over time\")\n\n\n\n\n# FINAL EXERCISE (playground):\n# Change ONE of the following and re-run:\n# 1) noffpermother = 1 vs 5  (drift strength changes)\n# 2) panel selection method (e.g., method=\"fst\" or another you used earlier)\n# 3) number of populations included (e.g., first 5 vs first 9)\n#\n# QUESTIONS:\n# - Does panel performance decay faster or slower?\n# - Why?",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>W13 Simulations</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W13/W13.html#additional-reading",
    "href": "inst/tutorials/W13/W13.html#additional-reading",
    "title": "13  W13 Simulations",
    "section": "Additional reading",
    "text": "Additional reading\nAnything else you want to add?",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>W13 Simulations</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W13/W13.html#exercises",
    "href": "inst/tutorials/W13/W13.html#exercises",
    "title": "13  W13 Simulations",
    "section": "Exercises",
    "text": "Exercises\nExercises where they can use their own data or supplied data to try out what they have learnt in a new context.\n\ndot points\nfor different steps",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>W13 Simulations</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W13/W13.html#winding-up",
    "href": "inst/tutorials/W13/W13.html#winding-up",
    "title": "13  W13 Simulations",
    "section": "Winding up",
    "text": "Winding up\n###Discussion Time\nAdd some questions to help group discussion.\n\nWhere have we come?\nSummarise what they should have learnt.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>W13 Simulations</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W14/W14.html",
    "href": "inst/tutorials/W14/W14.html",
    "title": "14  W14 SNP panels",
    "section": "",
    "text": "W14 SNP panels",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>W14 SNP panels</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W14/W14.html#introduction",
    "href": "inst/tutorials/W14/W14.html#introduction",
    "title": "14  W14 SNP panels",
    "section": "Introduction",
    "text": "Introduction\n\nLearning outcomes\nWhat is the goal of this session? What will participants learn?\n\n\nPrerquisites\nWhat prior knowledge do they need?\n\n\nWorkflow\nWhat is the structure of the session?\n\n\nAdditional reading\nAnything else you want to add?",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>W14 SNP panels</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W14/W14.html#topic",
    "href": "inst/tutorials/W14/W14.html#topic",
    "title": "14  W14 SNP panels",
    "section": "Topic",
    "text": "Topic\nBrief recap of the topic, relating back to the presentation.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>W14 SNP panels</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W14/W14.html#worked-ex",
    "href": "inst/tutorials/W14/W14.html#worked-ex",
    "title": "14  W14 SNP panels",
    "section": "Worked Ex:",
    "text": "Worked Ex:\nWorked example that everyone steps through together - simple example applying the methods\n\n# We show them the code to run",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>W14 SNP panels</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W14/W14.html#exercises",
    "href": "inst/tutorials/W14/W14.html#exercises",
    "title": "14  W14 SNP panels",
    "section": "Exercises",
    "text": "Exercises\nExercises where they can use their own data or supplied data to try out what they have learnt in a new context.\n\ndot points\nfor different steps",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>W14 SNP panels</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W14/W14.html#winding-up",
    "href": "inst/tutorials/W14/W14.html#winding-up",
    "title": "14  W14 SNP panels",
    "section": "Winding up",
    "text": "Winding up\n\nDiscussion Time\nAdd some questions to help group discussion.\n\n\nWhere have we come?\nSummarise what they should have learnt.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>W14 SNP panels</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W15/W15.html",
    "href": "inst/tutorials/W15/W15.html",
    "title": "15  W15 Relatedness",
    "section": "",
    "text": "W15 Relatedness",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>W15 Relatedness</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W15/W15.html#introduction",
    "href": "inst/tutorials/W15/W15.html#introduction",
    "title": "15  W15 Relatedness",
    "section": "Introduction",
    "text": "Introduction\n\nLearning outcomes\nWhat is the goal of this session? What will participants learn?\n\n\nPrerquisites\nWhat prior knowledge do they need?\n\n\nWorkflow\nWhat is the structure of the session?\n\n\nAdditional reading\nAnything else you want to add?",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>W15 Relatedness</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W15/W15.html#topic",
    "href": "inst/tutorials/W15/W15.html#topic",
    "title": "15  W15 Relatedness",
    "section": "Topic",
    "text": "Topic\nBrief recap of the topic, relating back to the presentation.",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>W15 Relatedness</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W15/W15.html#worked-ex",
    "href": "inst/tutorials/W15/W15.html#worked-ex",
    "title": "15  W15 Relatedness",
    "section": "Worked Ex:",
    "text": "Worked Ex:\nWorked example that everyone steps through together - simple example applying the methods\n\n# We show them the code to run",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>W15 Relatedness</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W15/W15.html#exercises",
    "href": "inst/tutorials/W15/W15.html#exercises",
    "title": "15  W15 Relatedness",
    "section": "Exercises",
    "text": "Exercises\nExercises where they can use their own data or supplied data to try out what they have learnt in a new context.\n\ndot points\nfor different steps",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>W15 Relatedness</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W15/W15.html#winding-up",
    "href": "inst/tutorials/W15/W15.html#winding-up",
    "title": "15  W15 Relatedness",
    "section": "Winding up",
    "text": "Winding up\n\nDiscussion Time\nAdd some questions to help group discussion.\n\n\nWhere have we come?\nSummarise what they should have learnt.",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>W15 Relatedness</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W16/W16.html",
    "href": "inst/tutorials/W16/W16.html",
    "title": "16  W16 Sequencing Technologies",
    "section": "",
    "text": "W16 Sequencing Technologies",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>W16 Sequencing Technologies</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W16/W16.html#introduction",
    "href": "inst/tutorials/W16/W16.html#introduction",
    "title": "16  W16 Sequencing Technologies",
    "section": "Introduction",
    "text": "Introduction\n\nLearning outcomes\nWhat is the goal of this session? What will participants learn?\n\n\nPrerquisites\nWhat prior knowledge do they need?\n\n\nWorkflow\nWhat is the structure of the session?\n\n\nAdditional reading\nAnything else you want to add?",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>W16 Sequencing Technologies</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W16/W16.html#topic",
    "href": "inst/tutorials/W16/W16.html#topic",
    "title": "16  W16 Sequencing Technologies",
    "section": "Topic",
    "text": "Topic\nBrief recap of the topic, relating back to the presentation.",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>W16 Sequencing Technologies</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W16/W16.html#worked-ex",
    "href": "inst/tutorials/W16/W16.html#worked-ex",
    "title": "16  W16 Sequencing Technologies",
    "section": "Worked Ex:",
    "text": "Worked Ex:\nWorked example that everyone steps through together - simple example applying the methods\n\n# We show them the code to run",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>W16 Sequencing Technologies</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W16/W16.html#exercises",
    "href": "inst/tutorials/W16/W16.html#exercises",
    "title": "16  W16 Sequencing Technologies",
    "section": "Exercises",
    "text": "Exercises\nExercises where they can use their own data or supplied data to try out what they have learnt in a new context.\n\ndot points\nfor different steps",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>W16 Sequencing Technologies</span>"
    ]
  },
  {
    "objectID": "inst/tutorials/W16/W16.html#winding-up",
    "href": "inst/tutorials/W16/W16.html#winding-up",
    "title": "16  W16 Sequencing Technologies",
    "section": "Winding up",
    "text": "Winding up\n\nDiscussion Time\nAdd some questions to help group discussion.\n\n\nWhere have we come?\nSummarise what they should have learnt.",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>W16 Sequencing Technologies</span>"
    ]
  }
]