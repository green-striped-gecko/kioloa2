<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Bernd Gruber &amp; Luis Mijangos">
<meta name="description" content="Kioloa2 Simuations">

<title>3&nbsp; Simulations – Analysing Genomic Data with dartRverse</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../inst/tutorials/session1/session1.html" rel="prev">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-70a47bd5681a7291082a5b9f83d58762.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../dartR_style.css">
</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../inst/tutorials/session2_sim/session2_sim.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Simulations</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../../../index.html" class="sidebar-logo-link">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="../../../">Analysing Genomic Data with dartRverse</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome!</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../schedule.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Program</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../inst/tutorials/session0/session0.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">dartRverse</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../inst/tutorials/session1/session1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">EpisodeII: Attack of the Clades</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../inst/tutorials/session2_sim/session2_sim.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Simulations</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#simulations-for-conservation" id="toc-simulations-for-conservation" class="nav-link active" data-scroll-target="#simulations-for-conservation">Simulations for Conservation</a></li>
  <li><a href="#learning-outcomes" id="toc-learning-outcomes" class="nav-link" data-scroll-target="#learning-outcomes">Learning outcomes</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a>
  <ul>
  <li><a href="#using-simulations-in-the-dartrverse-for-conservation-genetics" id="toc-using-simulations-in-the-dartrverse-for-conservation-genetics" class="nav-link" data-scroll-target="#using-simulations-in-the-dartrverse-for-conservation-genetics">Using simulations in the dartRverse for conservation genetics</a>
  <ul class="collapse">
  <li><a href="#why-simulate-in-a-conservation-context" id="toc-why-simulate-in-a-conservation-context" class="nav-link" data-scroll-target="#why-simulate-in-a-conservation-context">Why simulate in a conservation context?</a></li>
  <li><a href="#a-modular-lego-style-simulation-philosophy" id="toc-a-modular-lego-style-simulation-philosophy" class="nav-link" data-scroll-target="#a-modular-lego-style-simulation-philosophy">A modular, “lego-style” simulation philosophy</a></li>
  <li><a href="#building-complexity-incrementally" id="toc-building-complexity-incrementally" class="nav-link" data-scroll-target="#building-complexity-incrementally">Building complexity incrementally</a></li>
  <li><a href="#typical-conservation-genetics-use-cases" id="toc-typical-conservation-genetics-use-cases" class="nav-link" data-scroll-target="#typical-conservation-genetics-use-cases">Typical conservation genetics use cases</a></li>
  <li><a href="#from-exploration-to-decision-support" id="toc-from-exploration-to-decision-support" class="nav-link" data-scroll-target="#from-exploration-to-decision-support">From exploration to decision support</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#prerequisites-and-background-knowledge" id="toc-prerequisites-and-background-knowledge" class="nav-link" data-scroll-target="#prerequisites-and-background-knowledge">Prerequisites and background knowledge</a></li>
  <li><a href="#session-overview" id="toc-session-overview" class="nav-link" data-scroll-target="#session-overview">Session overview</a></li>
  <li><a href="#setup" id="toc-setup" class="nav-link" data-scroll-target="#setup">Setup</a></li>
  <li><a href="#tutorial" id="toc-tutorial" class="nav-link" data-scroll-target="#tutorial">Tutorial</a></li>
  <li><a href="#sim-1-a-simple-simulation" id="toc-sim-1-a-simple-simulation" class="nav-link" data-scroll-target="#sim-1-a-simple-simulation">Sim 1: A simple simulation</a>
  <ul>
  <li><a href="#exercise" id="toc-exercise" class="nav-link" data-scroll-target="#exercise">Exercise:</a></li>
  </ul></li>
  <li><a href="#sim-2-starting-conditions-for-simulations" id="toc-sim-2-starting-conditions-for-simulations" class="nav-link" data-scroll-target="#sim-2-starting-conditions-for-simulations">Sim 2: Starting conditions for simulations</a>
  <ul>
  <li><a href="#gl.sim.ind-scaling-up-a-well-sampled-population" id="toc-gl.sim.ind-scaling-up-a-well-sampled-population" class="nav-link" data-scroll-target="#gl.sim.ind-scaling-up-a-well-sampled-population"><code>gl.sim.ind</code>: scaling up a well-sampled population</a>
  <ul class="collapse">
  <li><a href="#gl.sim.neconst-a-generic-starting-population" id="toc-gl.sim.neconst-a-generic-starting-population" class="nav-link" data-scroll-target="#gl.sim.neconst-a-generic-starting-population">2.2 <code>gl.sim.Neconst</code>: a generic starting population</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sim-3-drift-driven-divergence-between-isolated-populations-fst" id="toc-sim-3-drift-driven-divergence-between-isolated-populations-fst" class="nav-link" data-scroll-target="#sim-3-drift-driven-divergence-between-isolated-populations-fst">Sim 3: Drift-driven divergence between isolated populations (Fst)</a></li>
  <li><a href="#sim-4-adding-demography-birth-death-carrying-capacity" id="toc-sim-4-adding-demography-birth-death-carrying-capacity" class="nav-link" data-scroll-target="#sim-4-adding-demography-birth-death-carrying-capacity">Sim 4: Adding demography (birth, death, carrying capacity)</a></li>
  <li><a href="#sim-5-snp-panel-performance-through-time" id="toc-sim-5-snp-panel-performance-through-time" class="nav-link" data-scroll-target="#sim-5-snp-panel-performance-through-time">Sim 5: SNP panel performance through time</a>
  <ul>
  <li><a href="#build-and-evaluate-a-panel-at-time-0" id="toc-build-and-evaluate-a-panel-at-time-0" class="nav-link" data-scroll-target="#build-and-evaluate-a-panel-at-time-0">5.1 Build and evaluate a panel at time 0</a></li>
  <li><a href="#simulate-forward-and-check-panel-performance-over-time" id="toc-simulate-forward-and-check-panel-performance-over-time" class="nav-link" data-scroll-target="#simulate-forward-and-check-panel-performance-over-time">5.2 Simulate forward and check panel performance over time</a></li>
  </ul></li>
  <li><a href="#additional-reading" id="toc-additional-reading" class="nav-link" data-scroll-target="#additional-reading">Additional reading</a></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises">Exercises</a></li>
  <li><a href="#winding-up" id="toc-winding-up" class="nav-link" data-scroll-target="#winding-up">Winding up</a>
  <ul>
  <li><a href="#where-have-we-come" id="toc-where-have-we-come" class="nav-link" data-scroll-target="#where-have-we-come">Where have we come?</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Simulations</span></h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Bernd Gruber &amp; Luis Mijangos </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">Invalid Date</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<div class="cell">
<div class="cell-output-display">
<script>
  addClassKlippyTo("pre.r, pre.markdown");
  addKlippy('right', 'top', '#000000', '1', 'Copy code', 'Copied!');
</script>
</div>
</div>
<section id="simulations-for-conservation" class="level2">
<h2 class="anchored" data-anchor-id="simulations-for-conservation">Simulations for Conservation</h2>
<p><em>Session Presenters</em></p>
<p><img src="images/Presenters7.png" class="img-fluid"> and Luis</p>
</section>
<section id="learning-outcomes" class="level2">
<h2 class="anchored" data-anchor-id="learning-outcomes">Learning outcomes</h2>
<p>In this session we will learn how to run simulations within the dartRverse.</p>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<section id="using-simulations-in-the-dartrverse-for-conservation-genetics" class="level3">
<h3 class="anchored" data-anchor-id="using-simulations-in-the-dartrverse-for-conservation-genetics">Using simulations in the dartRverse for conservation genetics</h3>
<p>Simulation is one of the most powerful yet underused tools in conservation genetics. While empirical SNP datasets tell us what <em>has happened</em>, simulations allow us to ask <em>what could happen</em> under alternative management scenarios—and to do so quickly, transparently, and reproducibly. Within the <strong>dartRverse</strong>, simulations are designed as lightweight, modular building blocks that integrate naturally with SNP-based analyses used in applied conservation genetics.</p>
<p>At its core, the dartRverse simulation framework is not intended to compete with full forward-time population genetic simulators. Instead, it aims to provide <strong>rapid, interpretable simulations</strong> that allow conservation practitioners and researchers to explore genetic consequences of simplified demographic and management scenarios using the same data structures and summary statistics they already use for real populations.</p>
<hr>
<section id="why-simulate-in-a-conservation-context" class="level4">
<h4 class="anchored" data-anchor-id="why-simulate-in-a-conservation-context">Why simulate in a conservation context?</h4>
<p>Many conservation questions are fundamentally <em>dynamic</em>:</p>
<ul>
<li>How quickly will a small population lose genetic variation through drift?</li>
<li>How many generations does it take to lose 50% of heterozygosity under a given effective population size?</li>
<li>How effective is supplementation or translocation at preserving allelic diversity?</li>
<li>How fast do populations diverge when connectivity is reduced?</li>
<li>How do metapopulation dynamics influence genetic differentiation, inbreeding, or genetic rescue outcomes?</li>
</ul>
<p>Simulations allow these questions to be explored explicitly, often with simple assumptions, before committing to costly or irreversible management actions.</p>
<hr>
</section>
<section id="a-modular-lego-style-simulation-philosophy" class="level4">
<h4 class="anchored" data-anchor-id="a-modular-lego-style-simulation-philosophy">A modular, “lego-style” simulation philosophy</h4>
<p>The dartRverse approaches simulations as a sequence of <strong>simple, composable processes</strong>. Rather than defining an entire demographic model upfront, users build scenarios by chaining together a small number of intuitive functions—much like assembling lego pieces.</p>
<p>At a conceptual level, simulations revolve around four core processes:</p>
<section id="population-creation" class="level5">
<h5 class="anchored" data-anchor-id="population-creation">1. Population creation</h5>
<p>Populations can be generated <em>de novo</em> or derived directly from empirical SNP datasets. This allows simulations to begin from realistic allele frequencies, levels of heterozygosity, and population structure, rather than abstract starting conditions.</p>
</section>
<section id="drift-and-mutation" class="level5">
<h5 class="anchored" data-anchor-id="drift-and-mutation">2. Drift and mutation</h5>
<p>Allele frequencies change over generations due to genetic drift, with optional mutation. Even under extremely simple population dynamics, this immediately illustrates how small effective population sizes rapidly erode genetic diversity—often far faster than expected.</p>
</section>
<section id="survival-and-migration" class="level5">
<h5 class="anchored" data-anchor-id="survival-and-migration">3. Survival and migration</h5>
<p>Individuals can survive, be removed, or migrate between populations. This enables exploration of connectivity, fragmentation, and metapopulation dynamics without invoking complex spatially explicit models.</p>
</section>
<section id="reproduction" class="level5">
<h5 class="anchored" data-anchor-id="reproduction">4. Reproduction</h5>
<p>Reproduction can be modelled through simple cloning or sexual reproduction, allowing users to explore consequences for heterozygosity, inbreeding, and relatedness under different mating systems.</p>
<p>Each step produces SNP data in familiar dartR objects, making it trivial to calculate standard diversity metrics at any point in the simulation.</p>
<hr>
</section>
</section>
<section id="building-complexity-incrementally" class="level4">
<h4 class="anchored" data-anchor-id="building-complexity-incrementally">Building complexity incrementally</h4>
<p>A key strength of this approach is that <strong>complex dynamics emerge from simple rules</strong>. By combining basic processes, users can rapidly construct realistic conservation scenarios, such as:</p>
<ul>
<li>Periodic supplementation (e.g.&nbsp;adding individuals every five generations)</li>
<li>Founder events followed by isolation</li>
<li>Asymmetric migration between source and sink populations</li>
<li>Temporary corridors that restore gene flow for limited time periods</li>
</ul>
<p>Because simulations are embedded in R, users can easily extend them further—for example by introducing sex- or age-dependent survival, stochastic catastrophes, or spatial structure linked to resistance surfaces and home ranges.</p>
<hr>
</section>
<section id="typical-conservation-genetics-use-cases" class="level4">
<h4 class="anchored" data-anchor-id="typical-conservation-genetics-use-cases">Typical conservation genetics use cases</h4>
<p>Some common applications of dartRverse simulations include:</p>
<ul>
<li><p><strong>Genetic drift over time</strong><br>
Tracking loss of heterozygosity or allelic richness across generations under different effective population sizes.</p></li>
<li><p><strong>Supplementation and genetic rescue</strong><br>
Evaluating how many individuals are required, and how often, to maintain genetic diversity or slow inbreeding.</p></li>
<li><p><strong>Metapopulation dynamics</strong><br>
Exploring how migration rates influence differentiation, extinction–recolonisation dynamics, and long-term persistence.</p></li>
<li><p><strong>Temporal change in population structure</strong><br>
Monitoring trajectories of population differentiation, relatedness, or inbreeding coefficients as populations diverge or reconnect.</p></li>
</ul>
<p>Because simulated datasets are analysed using the same summary statistics as empirical SNP data, results are immediately interpretable and directly comparable to real monitoring data.</p>
<hr>
</section>
<section id="from-exploration-to-decision-support" class="level4">
<h4 class="anchored" data-anchor-id="from-exploration-to-decision-support">From exploration to decision support</h4>
<p>Ultimately, simulations in the dartRverse allow conservation geneticists to test assumptions, visualise outcomes, and communicate genetic risks and benefits to managers and stakeholders. Even highly simplified simulations can provide powerful insights into how quickly genetic diversity can be lost—and how strategic interventions can slow, or even reverse, that loss. In this way, simulations become not just a teaching tool, but a practical component of evidence-based conservation decision-making.</p>
<p>Please be aware dartRverse is not a fully fledged simulation tool. It allows to do quick and easy simulations, but for a comprehensive simulation framework you should consider using <code>SLIM</code>. By the way there is a cool package called ‘slimR’ which allows to integrate and run simulations from within R (and it talk to the dartRverse for analysis).</p>
</section>
</section>
</section>
<section id="prerequisites-and-background-knowledge" class="level2">
<h2 class="anchored" data-anchor-id="prerequisites-and-background-knowledge">Prerequisites and background knowledge</h2>
<p>Simulations in the dartRverse can range from very simple to highly complex. At the simplest level, many conservation scenarios can be explored using built-in dartRverse functions with minimal coding, making simulations accessible to users with basic R skills. More advanced applications, however, require custom workflows written directly in R, where dartRverse functions are combined with user-defined logic to represent realistic demographic, genetic, or management processes.</p>
<p>As a result, <strong>a working knowledge of R programming and familiarity with dartR data objects</strong> (e.g.&nbsp;<code>genlight</code>, `dartR’ and related structures) is essential. Simulations often require small but important data transformations, such as subsetting populations, updating metadata, reshaping outputs, or tracking summary statistics across generations. When individual simulation runs become computationally intensive—particularly when stochasticity is important—it is common to repeat simulations hundreds or thousands of times. In these cases, <strong>parallelisation</strong> (using standard R tools) becomes critical for keeping runtimes practical.</p>
<p>Finally, simulations are only as informative as the questions they are designed to address. Users therefore need a solid understanding of <strong>population genetic concepts</strong> and appropriate metrics for quantifying genetic change. This includes knowing when to track heterozygosity, allelic richness, inbreeding, or population differentiation, and how these measures relate to processes such as drift, migration, and supplementation. Thoughtful choice of summary statistics is key to translating simulation outputs into meaningful conservation insights.</p>
</section>
<section id="session-overview" class="level2">
<h2 class="anchored" data-anchor-id="session-overview">Session overview</h2>
<p>This session introduces simulations in the dartRverse using a <strong>step-by-step complexity approach</strong>. We begin with very simple simulations and progressively add biological and demographic realism.</p>
<ul>
<li><strong>Sim 1: A simple simulation</strong>
<ul>
<li>Create a population from existing SNP data</li>
<li>Simulate genetic drift over generations</li>
<li>Track simple diversity metrics (e.g.&nbsp;heterozygosity over time)</li>
</ul></li>
<li><strong>Sim 2: Replication and uncertainty</strong>
<ul>
<li>Repeat simulations to capture stochasticity</li>
<li>Visualise variability among simulation runs</li>
<li>Interpret expected vs realised genetic trajectories</li>
</ul></li>
<li><strong>Sim 3: Population divergence</strong>
<ul>
<li>Simulate multiple isolated populations</li>
<li>Explore how genetic differentiation (e.g.&nbsp;FST) increases over time</li>
<li>Introduce migration to illustrate connectivity effects</li>
</ul></li>
<li><strong>Sim 4: Demography and reproduction</strong>
<ul>
<li>Add survival and reproduction processes</li>
<li>Explore population size limits and allele loss</li>
<li>Link demographic parameters to genetic outcomes</li>
</ul></li>
<li><strong>Sim 5: Applied conservation questions</strong>
<ul>
<li>Supplementation and genetic rescue scenarios</li>
<li>Metapopulation dynamics</li>
<li>Performance of SNP panels through time</li>
</ul></li>
<li><strong>Wrap-up</strong>
<ul>
<li>Key insights from simple vs complex simulations</li>
<li>When dartRverse simulations are sufficient</li>
<li>When to move to more detailed forward simulators</li>
</ul></li>
</ul>
</section>
<section id="setup" class="level2">
<h2 class="anchored" data-anchor-id="setup">Setup</h2>
<p>To setup the session, we need to load the necessary libraries. The main one is <code>dartRverse</code> which contains all the functions we will use for simulations and analysis. We also load <code>ggplot2</code> and <code>tidyr</code> for data manipulation and visualization. Make sure you have these packages installed and loaded before proceeding with the tutorial and also make sure the <code>dartRverse</code> package is up to date, as the simulation functions are relatively new and may have been updated since the last release.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dartRverse)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyr)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="tutorial" class="level2">
<h2 class="anchored" data-anchor-id="tutorial">Tutorial</h2>
</section>
<section id="sim-1-a-simple-simulation" class="level2">
<h2 class="anchored" data-anchor-id="sim-1-a-simple-simulation">Sim 1: A simple simulation</h2>
<p>The dartRverse allows to run time forward simulations. Often you want to run some simulation based on an existing genlight object.</p>
<p>We load some example data</p>
<div class="cell" data-exercise.lines="5">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>rfbe <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"./data/rfbe.rds"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>and then run the gl.report.basics function to check its content. Have a look at the output and feel free to explore the dataset further using other functions. You can for example check the the amount of missing data or the number of individuals in each population.</p>
<div class="cell" data-exercise="true" data-exercise.setup="ex_71-setup">
<div class="gold-panel">
<div class="tutorial-exercise" data-label="ex71_2" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0" data-pipe="|>">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gl.report.basics</span>(rfbe)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
</div>
<p>The next step is to think about a simulation scenario. Here we come up with a very simple one:</p>
<div class="callout callout-style-simple callout-none no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">None</span>Scenario
</div>
</div>
<div class="callout-body-container callout-body">
<p>A new population is founded by translocating ten individuals from one of the populations in the data set (PJTub1.2.3). The population evolves for 15 generations under a drift-only Wright–Fisher process with no sexual reproduction, no mutation, and no additional releases, allowing us to examine the loss of heterozygosity through time.</p>
</div>
</div>
<p>So lets create a new population from the existing one by subsetting the dartR object and then subsample 10 individuals from it.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># copy only the source population int a new dartR object</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>source <span class="ot">&lt;-</span> <span class="fu">gl.keep.pop</span>(rfbe, <span class="at">pop.list=</span><span class="st">"PJTub1.2.3"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Starting gl.keep.pop 
  Processing genlight object with SNP data
  Checking for presence of nominated populations
  Retaining only populations PJTub1.2.3 
  Warning: Resultant dataset may contain monomorphic loci
  Locus metrics not recalculated
Completed: gl.keep.pop </code></pre>
</div>
</div>
<p>Next, we inspect the source population to determine the number of individuals and the extent of missing data.</p>
<div class="cell" data-exercise="true" data-exercise.setup="ex_71-setup">
<div class="gold-panel">
<div class="tutorial-exercise" data-label="ex71_4" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0" data-pipe="|>">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="do">### number of individuals in the source population</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="do">### missing data in the genotypes of the source population</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
</div>
<p>As you can see there is missing data in the source population.</p>
<p>Missing genotypes are generally undesirable in simulations, as they require explicit assumptions about how missing alleles are handled during reproduction. To avoid introducing additional complexity at this stage, we remove loci with missing data by filtering (an alternative approach would be genotype imputation). In most simulation studies, it is preferable to work with complete datasets; however, there are situations where the effects of missing data are themselves of interest, in which case an explicit strategy for handling missingness is required.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">#remove missing data using a strict callrate filter</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>source2 <span class="ot">&lt;-</span> <span class="fu">gl.filter.callrate</span>(source, <span class="at">method=</span><span class="st">"loc"</span>, <span class="at">threshold=</span><span class="dv">1</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div class="cell" data-exercise="true" data-exercise.setup="ex_71-setup">
<div class="gold-panel">
<div class="tutorial-exercise" data-label="ex71_6" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0" data-pipe="|>">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">#check if there are no missing data in the genotypes of source2</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
</div>
<p>The next step is to create a new population of 10 individuals using the source2 population</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create a new population of 10 individuals using individuals from source2  </span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">7</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>newpop <span class="ot">&lt;-</span> <span class="fu">gl.subsample.ind</span>(source2, <span class="at">n=</span><span class="dv">10</span>, <span class="at">replace =</span> <span class="cn">FALSE</span>, <span class="at">verbose =</span> <span class="dv">0</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div class="cell" data-exercise="true" data-exercise.setup="ex_71-setup">
<div class="gold-panel">
<div class="tutorial-exercise" data-label="ex71_8" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0" data-pipe="|>">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">#check number of individuals and missing data in newpop</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
</div>
<p>As we want to observe the change in heterozygosity we calculate heterozygosity for this populuation</p>
<div class="cell" data-exercise="true" data-exercise.setup="ex_71-setup">
<div class="gold-panel">
<div class="tutorial-exercise" data-label="ex71_9" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0" data-pipe="|>">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">#find a way to calculate the mean heterozygosity of the new population</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
</div>
<p>The next step is then repeat this for 15 generations (assuming an ideal poulation for simplicity)</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">#we create a vector that holds heterozygosity over generation</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="cn">NA</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">#He of Generation 1</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>res[<span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="fu">mean</span>(<span class="fu">gl.He</span>(newpop))</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (gen <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span><span class="dv">15</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">#ideal popluation = cloning snails</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>  newpop <span class="ot">&lt;-</span> <span class="fu">gl.sim.ind</span>(newpop, <span class="at">n=</span><span class="dv">10</span>)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">#He of generation gen</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>  res[gen] <span class="ot">&lt;-</span> <span class="fu">mean</span>(<span class="fu">gl.He</span>(newpop))</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">cat</span>(<span class="st">"Generation"</span>, gen, <span class="st">"Heterozygosity:"</span>, res[gen], <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">flush.console</span>()</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="co">#Create a plot</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(res, <span class="at">type=</span><span class="st">"b"</span>, <span class="at">xlab=</span><span class="st">"Generation"</span>, <span class="at">ylab=</span><span class="st">"Expected heterozygosity"</span>, </span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>     <span class="at">main=</span><span class="st">"Simulation of expected heterozygosity over time"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>You can now change setting and play with the simulation. For example increase the number of generations or the number of initial founding individuals. You need to run the golden chunks in order to make sure all the objects are updated.</p>
<p>Here is the full simulation in one code block. Change to your liking. Eg. run more generations, or how does the simulation change if you sample from less/more individuals from the source, change the source population. Monitor observerd heterozygosity instead of experced.</p>
<div class="cell" data-exercise="true" data-exercise.setup="ex_71-setup">
<div class="gold-panel">
<div class="tutorial-exercise" data-label="ex71_11" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0" data-pipe="|>">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>rfbe <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"./data/rfbe.rds"</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>source <span class="ot">&lt;-</span> <span class="fu">gl.keep.pop</span>(rfbe, <span class="at">pop.list=</span><span class="st">"PJTub1.2.3"</span>, <span class="at">verbose=</span><span class="dv">0</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>source2 <span class="ot">&lt;-</span> <span class="fu">gl.filter.callrate</span>(source, <span class="at">method=</span><span class="st">"loc"</span>, <span class="at">threshold=</span><span class="dv">1</span>, <span class="at">verbose=</span><span class="dv">0</span>)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">7</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>newpop <span class="ot">&lt;-</span> <span class="fu">gl.subsample.ind</span>(source2, <span class="at">n=</span><span class="dv">10</span>, <span class="at">replace =</span> <span class="cn">FALSE</span>, <span class="at">verbose =</span> <span class="dv">0</span>)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>res<span class="ot">&lt;-</span><span class="cn">NA</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>res[<span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="fu">mean</span>(<span class="fu">gl.He</span>(newpop))</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (gen <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span><span class="dv">15</span>)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">#ideal popluation = cloning snails</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>  newpop <span class="ot">&lt;-</span> <span class="fu">gl.sim.ind</span>(newpop, <span class="at">n=</span><span class="dv">10</span>)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">#He of generation gen</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>  res[gen] <span class="ot">&lt;-</span> <span class="fu">mean</span>(<span class="fu">gl.He</span>(newpop))</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(res, <span class="at">type=</span><span class="st">"b"</span>, <span class="at">xlab=</span><span class="st">"Generation"</span>, <span class="at">ylab=</span><span class="st">"Expected heterozygosity"</span>, </span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>     <span class="at">main=</span><span class="st">"Simulation of expected heterozygosity over time"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
</div>
<p>This is a very simple simulation, but it shows the basic idea. You can also use the gl.sim.offspring function to simulate more complex scenarios, such as different mating systems and check the effect.</p>
<p>This was only one instance so we can repeat this simulation 10 times to get a better estimate of the expected heterozygosity over time. To do so we first create a function around the whole simulation (which makes life easier for repeats), as this will allow us to run the simulation in parallel using the <code>parallel</code> package.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>simHe <span class="ot">&lt;-</span> <span class="cf">function</span>(x, <span class="at">nInd=</span><span class="dv">10</span>, <span class="at">ngens=</span><span class="dv">20</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">#remove all missing data</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">#create a new genlight object based on allele frequencies from source2</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  transfer <span class="ot">&lt;-</span> <span class="fu">gl.subsample.ind</span>(x, <span class="at">n=</span>nInd, <span class="at">replace =</span> <span class="cn">FALSE</span>, <span class="at">verbose =</span> <span class="dv">0</span>)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>  res <span class="ot">&lt;-</span> <span class="fu">mean</span>(<span class="fu">gl.He</span>(transfer))   <span class="co">#mean heterozygosity </span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (gen <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span>ngens)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">#cloning snails</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    transfer <span class="ot">&lt;-</span> <span class="fu">gl.sim.offspring</span>(transfer, transfer, <span class="at">noffpermother =</span> <span class="dv">1</span>)</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    res[gen] <span class="ot">&lt;-</span> <span class="fu">mean</span>(<span class="fu">gl.He</span>(transfer))</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(res)</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Now we run the simulation by a simple call to the function. You can change the number of generations and the number of individuals in the founding population to see how it affects the expected heterozygosity over time.</p>
<div class="cell" data-exercise="true" data-exercise.setup="ex_71-setup">
<div class="gold-panel">
<div class="tutorial-exercise" data-label="ex71_13" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0" data-pipe="|>">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">#test the function</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>out <span class="ot">&lt;-</span> <span class="fu">simHe</span>(source2, <span class="at">nInd =</span> <span class="dv">30</span>, <span class="at">ngens =</span> <span class="dv">20</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(out, <span class="at">type=</span><span class="st">"b"</span>, <span class="at">xlab=</span><span class="st">"Generation"</span>, <span class="at">ylab=</span><span class="st">"Expected heterozygosity"</span>,</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>     <span class="at">main=</span><span class="st">"Simulation of expected heterozygosity over time"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="session2_sim_files/figure-html/ex71_13-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
</div>
<p>The step to parallelise them is straightforward. We can use the future package to run the simulations in parallel. This is especially useful when we want to run a large number of simulations (e.g., 100 or more) to capture the stochasticity of the process.</p>
<div class="cell" data-exercise="true" data-exercise.setup="ex_71-setup" data-exercise.timelimit="120">
<div class="gold-panel">
<div class="tutorial-exercise" data-label="ex71_14" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0" data-pipe="|>">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(future.apply)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plan</span>(multisession, <span class="at">workers=</span><span class="dv">3</span>) <span class="co"># or plan(multicore) on Unix-like systems</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>n_sims <span class="ot">&lt;-</span> <span class="dv">9</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>sim_results <span class="ot">&lt;-</span> <span class="fu">future_lapply</span>(<span class="dv">1</span><span class="sc">:</span>n_sims, <span class="cf">function</span>(i) {</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">simHe</span>(source2, <span class="at">nInd =</span> <span class="dv">30</span>, <span class="at">ngens =</span> <span class="dv">20</span>)},  <span class="at">future.seed=</span><span class="cn">TRUE</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="co">#create a plot</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>outmat <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="fu">do.call</span>(cbind, sim_results))</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="fu">matplot</span>(outmat, <span class="at">type=</span><span class="st">"b"</span>, <span class="at">xlab=</span><span class="st">"Generation"</span>, <span class="at">ylab=</span><span class="st">"Expected heterozygosity"</span>,</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>        <span class="at">main=</span><span class="st">"Simulation of expected heterozygosity over time"</span>, <span class="at">col=</span><span class="dv">1</span><span class="sc">:</span>n_sims, <span class="at">pch=</span><span class="dv">1</span><span class="sc">:</span>n_sims)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
</div>
<section id="exercise" class="level4">
<h4 class="anchored" data-anchor-id="exercise">Exercise:</h4>
<p>Create a simulation of expected heterozygosity over time for the source population PJTub1.2.3, but this time transfer only 5 individuals and run the simulation for 50 generations. Repeat the simulation 5 times and plot the results using a boxplot. Or find another scenario you want to simulate. You can also change the gl.sim.offspring function to simulate more complex scenarios, such as different mating systems and check the effect.</p>
<div class="cell" data-exercise="true" data-exercise.setup="ex_71-setup">
<div class="gold-panel">
<div class="tutorial-exercise" data-label="ex71_15" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0" data-pipe="|>">
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
</div>
</section>
</section>
<section id="sim-2-starting-conditions-for-simulations" class="level2">
<h2 class="anchored" data-anchor-id="sim-2-starting-conditions-for-simulations">Sim 2: Starting conditions for simulations</h2>
<p>So far, we simulated a very simple <em>drift-only</em> Wright–Fisher process by repeatedly calling <code>gl.sim.ind()</code>. In practice, you often want to (i) <strong>scale up</strong> an empirical population to a larger starting population, or (ii) <strong>generate</strong> a starting population under a demographic model.</p>
<p>Two useful helper functions are:</p>
<ul>
<li><code>gl.sim.ind()</code>: creates individuals based on the <strong>current allele frequencies</strong> in a <code>genlight</code>/dartR object (good when allele frequencies are well-estimated).</li>
<li><code>gl.sim.Neconst()</code>: creates individuals based on a <strong>constant Ne</strong> and mutation rate (useful as a generic starting point; often followed by additional generations to reach realistic genotype structure).</li>
</ul>
<section id="gl.sim.ind-scaling-up-a-well-sampled-population" class="level3">
<h3 class="anchored" data-anchor-id="gl.sim.ind-scaling-up-a-well-sampled-population"><code>gl.sim.ind</code>: scaling up a well-sampled population</h3>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># (speed) use only 1000 loci</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>glsim_scale <span class="ot">&lt;-</span> <span class="fu">gl.sim.ind</span>(source2[,<span class="dv">1</span><span class="sc">:</span><span class="dv">1000</span>], <span class="at">n =</span> <span class="dv">100</span>, <span class="at">popname =</span> <span class="st">"scaled"</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="fu">gl.smearplot</span>(glsim_scale)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div class="cell" data-exercise="true" data-exercise.setup="ex_71-setup">
<div class="gold-panel">
<div class="tutorial-exercise" data-label="ex72_2" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0" data-pipe="|>">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># EXERCISE:</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="co"># 1) Change n to 50, 200 and compare the smearplots.</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 2) What happens if you use fewer loci (e.g., 200 loci)?</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
</div>
<section id="gl.sim.neconst-a-generic-starting-population" class="level4">
<h4 class="anchored" data-anchor-id="gl.sim.neconst-a-generic-starting-population">2.2 <code>gl.sim.Neconst</code>: a generic starting population</h4>
<p>This is often useful when you <em>don’t</em> have a well-sampled source population, but still want to explore “what-if” dynamics.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a starting population under constant Ne and mutation.</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Then generate offspring for a few generations using clones</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co"># start_pop &lt;- gl.sim.Neconst(Ne = 500, nloc = 1000, mu = 1e-8, nind = 100, popname = "Neconst")</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="co"># for (g in 1:5) start_pop &lt;- gl.sim.offspring(start_pop, start_pop, noffpermother = 1)</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="co"># gl.smearplot(start_pop)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div class="cell" data-exercise="true" data-exercise.setup="ex_71-setup">
<div class="gold-panel">
<div class="tutorial-exercise" data-label="ex72_4" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0" data-pipe="|>">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># DISCUSSION EXERCISE (no coding required):</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co"># When would you prefer gl.sim.ind() over gl.sim.Neconst() as a starting point?</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co"># (Think: allele frequencies, realism, availability of data.)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="sim-3-drift-driven-divergence-between-isolated-populations-fst" class="level2">
<h2 class="anchored" data-anchor-id="sim-3-drift-driven-divergence-between-isolated-populations-fst">Sim 3: Drift-driven divergence between isolated populations (Fst)</h2>
<p>To demonstrate <code>gl.sim.ind()</code> further, we simulate a simple expectation:</p>
<blockquote class="blockquote">
<p>If two populations are completely isolated, <strong>Fst increases over time</strong> (eventually approaching 1 at many loci).</p>
</blockquote>
<p>We create two populations of 10 individuals each, then evolve them for 20 generations under drift only, with <strong>no exchange</strong>.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>g1 <span class="ot">&lt;-</span> <span class="fu">gl.sim.ind</span>(source2[,<span class="dv">1</span><span class="sc">:</span><span class="dv">1000</span>], <span class="at">n =</span> <span class="dv">10</span>, <span class="at">popname =</span> <span class="st">"pop1"</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>g2 <span class="ot">&lt;-</span> <span class="fu">gl.sim.ind</span>(source2[,<span class="dv">1</span><span class="sc">:</span><span class="dv">1000</span>], <span class="at">n =</span> <span class="dv">10</span>, <span class="at">popname =</span> <span class="st">"pop2"</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>fst_mig <span class="ot">&lt;-</span> <span class="cn">NA</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">20</span>) {</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  g1 <span class="ot">&lt;-</span> <span class="fu">gl.sim.ind</span>(g1, <span class="at">n =</span> <span class="dv">10</span>, <span class="at">popname =</span> <span class="st">"pop1"</span>)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  g2 <span class="ot">&lt;-</span> <span class="fu">gl.sim.ind</span>(g2, <span class="at">n =</span> <span class="dv">10</span>, <span class="at">popname =</span> <span class="st">"pop2"</span>)</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="do">### migration (exchange of individuals between populations)</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># for example one individuals both ways</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># gg &lt;- rbind(g1, g2)</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>  <span class="co"># migtable &lt;- matrix(c(0,1,1,0), nrow=2, ncol=2) </span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">#  gg &lt;- gl.sim.emigration(gg, emi.table=migtable)</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">#  g1 &lt;- gg[pop="pop1",]</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">#  g2 &lt;- gg[pop="pop2",]</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a><span class="do">### calculate fst</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>  gg <span class="ot">&lt;-</span> <span class="fu">rbind</span>(g1, g2)</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>  fst_mig[i] <span class="ot">&lt;-</span> <span class="fu">gl.fst.pop</span>(gg, <span class="at">verbose =</span> <span class="dv">0</span>)[<span class="dv">2</span>, <span class="dv">1</span>]</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(fst_mig, <span class="at">type=</span><span class="st">"b"</span>, <span class="at">xlab=</span><span class="st">"Generation"</span>, <span class="at">ylab=</span><span class="st">"Fst"</span>, <span class="at">main=</span><span class="st">"Fst over time"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Below is the previous example with 2 populations, 10 individuals each and no exchange. Tun it and check how Fst changes over time. Then modify the code to add migration (exchange of individuals between populations) and see how Fst changes. You can for example swap 1 individual both ways each generation. Then compare your plot to the no-exchange plot above. What changes and why?</p>
<p>Questions:</p>
<ul>
<li>What changes if you increase population size?</li>
<li>What happens if you increase the number of migrants?</li>
<li>Remember there is the “Law” of 1 migrant per generation” which states that one migrant per generation is enough to prevent populations from diverging completely (i.e.&nbsp;Fst approaching 1).</li>
<li>also there is the formula: <span class="math display">\[F_{st} = \frac{1}{(4Nm + 1)} \]</span></li>
</ul>
<p>where N is the population size and m is the migration rate. This formula gives the expected Fst at equilibrium under a simple island model of migration. You can use this formula to predict the expected Fst for different values of N and m, and compare it to your simulation results.</p>
<div class="cell" data-exercise="true" data-exercise.setup="ex_71-setup" data-exercise.lines="26" data-exercise.timelimit="120">
<div class="gold-panel">
<div class="tutorial-exercise" data-label="ex73_2" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="26" data-pipe="|>">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>g1 <span class="ot">&lt;-</span> <span class="fu">gl.sim.ind</span>(source2[,<span class="dv">1</span><span class="sc">:</span><span class="dv">1000</span>], <span class="at">n =</span> <span class="dv">10</span>, <span class="at">popname =</span> <span class="st">"pop1"</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>g2 <span class="ot">&lt;-</span> <span class="fu">gl.sim.ind</span>(source2[,<span class="dv">1</span><span class="sc">:</span><span class="dv">1000</span>], <span class="at">n =</span> <span class="dv">10</span>, <span class="at">popname =</span> <span class="st">"pop2"</span>)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>fst_mig <span class="ot">&lt;-</span> <span class="cn">NA</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">20</span>) {</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  g1 <span class="ot">&lt;-</span> <span class="fu">gl.sim.ind</span>(g1, <span class="at">n =</span> <span class="dv">10</span>, <span class="at">popname =</span> <span class="st">"pop1"</span>)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  g2 <span class="ot">&lt;-</span> <span class="fu">gl.sim.ind</span>(g2, <span class="at">n =</span> <span class="dv">10</span>, <span class="at">popname =</span> <span class="st">"pop2"</span>)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="do">### migration (exchange of individuals between populations)</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># for example one individuals both ways</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># gg &lt;- rbind(g1, g2)</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>  <span class="co"># migtable &lt;- matrix(c(0,1,1,0), nrow=2, ncol=2) </span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">#  gg &lt;- gl.sim.emigration(gg, emi.table=migtable)</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">#  g1 &lt;- gg[pop="pop1",]</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">#  g2 &lt;- gg[pop="pop2",]</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a><span class="do">### calculate fst</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>  gg <span class="ot">&lt;-</span> <span class="fu">rbind</span>(g1, g2)</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>  fst_mig[i] <span class="ot">&lt;-</span> <span class="fu">gl.fst.pop</span>(gg, <span class="at">verbose =</span> <span class="dv">0</span>)[<span class="dv">2</span>, <span class="dv">1</span>]</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(fst_mig, <span class="at">type=</span><span class="st">"b"</span>, <span class="at">xlab=</span><span class="st">"Generation"</span>, <span class="at">ylab=</span><span class="st">"Fst"</span>, <span class="at">main=</span><span class="st">"Fst over time"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
</div>
</section>
<section id="sim-4-adding-demography-birth-death-carrying-capacity" class="level2">
<h2 class="anchored" data-anchor-id="sim-4-adding-demography-birth-death-carrying-capacity">Sim 4: Adding demography (birth, death, carrying capacity)</h2>
<p>Drift-only simulations are useful for intuition, but conservation scenarios often need <strong>survival</strong>, <strong>reproduction</strong>, and <strong>carrying capacity</strong>.</p>
<p>Below is a simple individual-based simulation (in the spirit of the Kioloa workflow):</p>
<ul>
<li>start from allele frequencies (via <code>gl.sim.ind</code>)</li>
<li>assign sex</li>
<li>create offspring (via <code>gl.sim.offspring</code>)</li>
<li>apply adult survival</li>
<li>apply carrying capacity (K)</li>
<li>quantify <strong>alleles lost</strong> after <em>ngens</em></li>
</ul>
<p>We wrap this into a function so we can explore parameters efficiently.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>sim_alleles_lost <span class="ot">&lt;-</span> <span class="cf">function</span>(x, <span class="at">ngens =</span> <span class="dv">30</span>, <span class="at">nind =</span> <span class="dv">100</span>, <span class="at">nloc =</span> <span class="dv">1000</span>,</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>                            <span class="at">surv =</span> <span class="fl">0.8</span>, <span class="at">repro =</span> <span class="dv">3</span>, <span class="at">K =</span> <span class="dv">100</span>) {</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># create starting population</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>  pop1 <span class="ot">&lt;-</span> <span class="fu">gl.sim.ind</span>(x, <span class="at">n =</span> nind, <span class="at">popname =</span> <span class="st">"pop1"</span>)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  pop1 <span class="ot">&lt;-</span> pop1[, <span class="dv">1</span><span class="sc">:</span>nloc]</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># allocate sex (stored in pop labels for convenience)</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pop</span>(pop1) <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="st">"M"</span>, <span class="st">"F"</span>), <span class="fu">nInd</span>(pop1), <span class="at">replace =</span> <span class="cn">TRUE</span>)</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (gen <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>ngens) {</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># offspring</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    off <span class="ot">&lt;-</span> <span class="fu">gl.sim.offspring</span>(<span class="at">fathers =</span> pop1[<span class="at">pop =</span> <span class="st">"M"</span>],</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>                            <span class="at">mothers =</span> pop1[<span class="at">pop =</span> <span class="st">"F"</span>],</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>                            <span class="at">noffpermother =</span> repro)</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pop</span>(off) <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="st">"M"</span>, <span class="st">"F"</span>), <span class="fu">nInd</span>(off), <span class="at">replace =</span> <span class="cn">TRUE</span>)</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># survival of adults</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>    keep <span class="ot">&lt;-</span> <span class="fu">rbinom</span>(<span class="fu">nInd</span>(pop1), <span class="at">size =</span> <span class="dv">1</span>, <span class="at">prob =</span> surv)</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>    pop1 <span class="ot">&lt;-</span> pop1[keep <span class="sc">==</span> <span class="dv">1</span>, ]</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># combine adults + offspring</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>    pop1 <span class="ot">&lt;-</span> <span class="fu">rbind</span>(pop1, off)</span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># enforce carrying capacity</span></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">nInd</span>(pop1) <span class="sc">&gt;</span> K) {</span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>      remove <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">nInd</span>(pop1), <span class="fu">nInd</span>(pop1) <span class="sc">-</span> K, <span class="at">replace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>      pop1 <span class="ot">&lt;-</span> pop1[<span class="sc">-</span>remove, ]</span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a>  <span class="co"># count loci where an allele has been lost </span></span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a>  <span class="co"># (works because genotypes are coded 0/1/2; allele lost -&gt; mean is exactly 0 or 2)</span></span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a>  alleles_lost <span class="ot">&lt;-</span> <span class="fu">sum</span>(<span class="fu">colMeans</span>(<span class="fu">as.matrix</span>(pop1)) <span class="sc">%%</span> <span class="dv">2</span> <span class="sc">==</span> <span class="dv">0</span>)</span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(alleles_lost)</span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Test the function on a starting dataset with no monomorphic loci:</p>
<div class="cell" data-exercise="true" data-exercise.setup="ex_71-setup">
<div class="gold-panel">
<div class="tutorial-exercise" data-label="ex74_2" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0" data-pipe="|>">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>start <span class="ot">&lt;-</span> <span class="fu">gl.filter.monomorphs</span>(source2, <span class="at">verbose =</span> <span class="dv">0</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>out <span class="ot">&lt;-</span> <span class="fu">sim_alleles_lost</span>(start, <span class="at">ngens =</span> <span class="dv">30</span>, <span class="at">nind =</span> <span class="dv">20</span>, <span class="at">nloc =</span> <span class="dv">1000</span>, <span class="at">surv =</span> <span class="fl">0.8</span>, <span class="at">repro =</span> <span class="dv">3</span>, <span class="at">K =</span> <span class="dv">100</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>out</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 236</code></pre>
</div>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
</div>
<div class="cell" data-exercise="true" data-exercise.setup="ex_71-setup">
<div class="gold-panel">
<div class="tutorial-exercise" data-label="ex74_3" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0" data-pipe="|>">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># EXERCISE:</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Run the same simulation, but change ONE parameter at a time.</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Try:</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 1) surv = 0.5 vs 0.9</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 2) K = 50 vs 200</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 3) nind = 20 vs 100</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Record (roughly) how alleles_lost changes and explain why.</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
</div>
<p>Now we can run a small parameter sweep. (Note: this can take a little time.)</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>paras <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">ngens =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>,</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">ninds =</span> <span class="dv">20</span>,</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">nlocs =</span> <span class="dv">1000</span>,</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">surv  =</span> <span class="fu">c</span>(<span class="fl">0.5</span>, <span class="fl">0.8</span>, <span class="fl">0.9</span>),</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">repro =</span> <span class="dv">3</span>,</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">K     =</span> <span class="dv">50</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">sapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(paras), <span class="cf">function</span>(i) {</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sim_alleles_lost</span>(start,</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>                   <span class="at">ngens =</span> paras<span class="sc">$</span>ngens[i],</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>                   <span class="at">nind  =</span> paras<span class="sc">$</span>ninds[i],</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>                   <span class="at">nloc  =</span> paras<span class="sc">$</span>nlocs[i],</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>                   <span class="at">surv  =</span> paras<span class="sc">$</span>surv[i],</span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>                   <span class="at">repro =</span> paras<span class="sc">$</span>repro[i],</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>                   <span class="at">K     =</span> paras<span class="sc">$</span>K[i])</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>paras<span class="sc">$</span>alleleslost <span class="ot">&lt;-</span> res</span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(paras, <span class="fu">aes</span>(<span class="at">x =</span> ngens, <span class="at">y =</span> alleleslost, <span class="at">group =</span> <span class="fu">factor</span>(ninds), <span class="at">color =</span> <span class="fu">factor</span>(ninds))) <span class="sc">+</span></span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>() <span class="sc">+</span></span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">x =</span> <span class="st">"Generations"</span>, <span class="at">y =</span> <span class="st">"Alleles lost"</span>, <span class="at">color =</span> <span class="st">"Population size"</span>) <span class="sc">+</span></span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span>surv)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div class="cell" data-exercise="true" data-exercise.setup="ex_71-setup">
<div class="gold-panel">
<div class="tutorial-exercise" data-label="ex74_5" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0" data-pipe="|>">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co"># EXERCISE:</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Modify the parameter grid to explore a different question.</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co"># For example:</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="co"># - let ninds vary (e.g., 20, 50, 100)</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="co"># - keep surv fixed, but vary K</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="co"># - increase ngens to 30 (warning: slower)</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Then re-run and interpret the plot.</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
</div>
</section>
<section id="sim-5-snp-panel-performance-through-time" class="level2">
<h2 class="anchored" data-anchor-id="sim-5-snp-panel-performance-through-time">Sim 5: SNP panel performance through time</h2>
<p>We learned how to select SNP panels — but how well do panels behave <strong>through time</strong> as populations drift?</p>
<p>Here we: 1) subselect some populations from the RFBE dataset,<br>
2) impute missing data,<br>
3) build a SNP panel (fast example: <code>method="pic"</code>),<br>
4) simulate forward and track <strong>panel performance</strong> over generations.</p>
<section id="build-and-evaluate-a-panel-at-time-0" class="level3">
<h3 class="anchored" data-anchor-id="build-and-evaluate-a-panel-at-time-0">5.1 Build and evaluate a panel at time 0</h3>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># keep the first 9 populations (example)</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>pops <span class="ot">&lt;-</span> <span class="fu">popNames</span>(rfbe)[<span class="dv">1</span><span class="sc">:</span><span class="dv">9</span>]</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>rfbe2 <span class="ot">&lt;-</span> <span class="fu">gl.keep.pop</span>(rfbe, <span class="at">pop.list =</span> pops, <span class="at">verbose =</span> <span class="dv">0</span>)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="co"># impute missing data</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>rfbe3 <span class="ot">&lt;-</span> <span class="fu">gl.impute</span>(rfbe2, <span class="at">method =</span> <span class="st">"neighbour"</span>)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="co"># build panel (50 loci) and evaluate</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>panel <span class="ot">&lt;-</span> <span class="fu">gl.select.panel</span>(rfbe3, <span class="at">method =</span> <span class="st">"pic"</span>, <span class="at">nl =</span> <span class="dv">50</span>, <span class="at">verbose =</span> <span class="dv">0</span>)</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>res0 <span class="ot">&lt;-</span> <span class="fu">gl.check.panel</span>(panel, rfbe3, <span class="at">parameter =</span> <span class="st">"Fst"</span>)</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>r2_0 <span class="ot">&lt;-</span> <span class="fu">summary</span>(<span class="fu">lm</span>(res0[,<span class="dv">1</span>] <span class="sc">~</span> res0[,<span class="dv">2</span>]))<span class="sc">$</span>r.squared</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>r2_0</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div class="cell" data-exercise="true" data-exercise.setup="ex_71-setup">
<div class="gold-panel">
<div class="tutorial-exercise" data-label="ex75_2" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0" data-pipe="|>">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># EXERCISE:</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Change panel size to nl = 25 and nl = 200.</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Does r2_0 increase? What do you expect and why?</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
</div>
</section>
<section id="simulate-forward-and-check-panel-performance-over-time" class="level3">
<h3 class="anchored" data-anchor-id="simulate-forward-and-check-panel-performance-over-time">5.2 Simulate forward and check panel performance over time</h3>
<p>We simulate each population forward independently (panmictic within-pop, no exchange among pops), then check how well the panel still predicts genome-wide Fst.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>xx <span class="ot">&lt;-</span> rfbe3</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>xx <span class="ot">&lt;-</span> xx[<span class="fu">order</span>(<span class="fu">pop</span>(xx)),]</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>out <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">NA</span>, <span class="dv">10</span>)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>out[<span class="dv">1</span>] <span class="ot">&lt;-</span> r2_0</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (g <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span><span class="dv">10</span>) {</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>  pops_list <span class="ot">&lt;-</span> <span class="fu">seppop</span>(xx)</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>  pops_list <span class="ot">&lt;-</span> <span class="fu">lapply</span>(pops_list, <span class="cf">function</span>(yy) {</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># simulate offspring within each population</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>    dummy <span class="ot">&lt;-</span> <span class="fu">gl.sim.offspring</span>(yy, yy, <span class="at">noffpermother =</span> <span class="dv">3</span>)</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># keep population size constant by resampling</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>    dummy <span class="ot">&lt;-</span> <span class="fu">gl.sample</span>(dummy, <span class="fu">nInd</span>(yy), <span class="at">replace =</span> <span class="cn">FALSE</span>, <span class="at">verbose =</span> <span class="dv">0</span>)</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(dummy)</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>  pops_next <span class="ot">&lt;-</span> <span class="fu">do.call</span>(rbind, pops_list)</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pop</span>(pops_next) <span class="ot">&lt;-</span> <span class="fu">pop</span>(xx)</span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>  res <span class="ot">&lt;-</span> <span class="fu">gl.check.panel</span>(panel, pops_next, <span class="at">parameter =</span> <span class="st">"Fst"</span>)</span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>  out[g] <span class="ot">&lt;-</span> <span class="fu">summary</span>(<span class="fu">lm</span>(res[,<span class="dv">1</span>] <span class="sc">~</span> res[,<span class="dv">2</span>]))<span class="sc">$</span>r.squared</span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a>  xx <span class="ot">&lt;-</span> pops_next</span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a>  <span class="fu">cat</span>(<span class="fu">paste</span>(<span class="st">"Generation"</span>, g, <span class="st">"R-squared:"</span>, out[g], <span class="st">"</span></span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a><span class="st">"</span>))</span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">flush.console</span>()</span>
<span id="cb31-30"><a href="#cb31-30" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-31"><a href="#cb31-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-32"><a href="#cb31-32" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(out, <span class="at">type=</span><span class="st">"b"</span>, <span class="at">xlab=</span><span class="st">"Generation"</span>, <span class="at">ylab=</span><span class="st">"R-squared"</span>, </span>
<span id="cb31-33"><a href="#cb31-33" aria-hidden="true" tabindex="-1"></a>     <span class="at">main=</span><span class="st">"Performance of SNP panel over time"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div class="cell" data-exercise="true" data-exercise.setup="ex_71-setup">
<div class="gold-panel">
<div class="tutorial-exercise" data-label="ex75_4" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0" data-pipe="|>">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co"># FINAL EXERCISE (playground):</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Change ONE of the following and re-run:</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 1) noffpermother = 1 vs 5  (drift strength changes)</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 2) panel selection method (e.g., method="fst" or another you used earlier)</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 3) number of populations included (e.g., first 5 vs first 9)</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="co"># QUESTIONS:</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="co"># - Does panel performance decay faster or slower?</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="co"># - Why?</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
</div>
</section>
</section>
<section id="additional-reading" class="level2">
<h2 class="anchored" data-anchor-id="additional-reading">Additional reading</h2>
<p>Anything else you want to add?</p>
</section>
<section id="exercises" class="level2">
<h2 class="anchored" data-anchor-id="exercises">Exercises</h2>
<p>Exercises where they can use their own data or supplied data to try out what they have learnt in a new context.</p>
<ul>
<li>dot points</li>
<li>for different steps</li>
</ul>
</section>
<section id="winding-up" class="level2">
<h2 class="anchored" data-anchor-id="winding-up">Winding up</h2>
<p>###Discussion Time</p>
<p>Add some questions to help group discussion.</p>
<section id="where-have-we-come" class="level3">
<h3 class="anchored" data-anchor-id="where-have-we-come">Where have we come?</h3>
<p>Summarise what they should have learnt.</p>
<p>
<script type="application/shiny-prerendered" data-context="server">
learnr:::register_http_handlers(session, metadata = NULL)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::prepare_tutorial_state(session)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::i18n_observe_tutorial_language(input, session)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
session$onSessionEnded(function() {
        learnr:::event_trigger(session, "session_stop")
      })
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ex71_2-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ex71_2-code-editor`)), session)
output$`tutorial-exercise-ex71_2-output` <- renderUI({
  `tutorial-exercise-ex71_2-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ex71_2", global_setup = NULL, setup = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
    chunks = list(list(label = "ex_71-setup", code = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
        opts = list(label = "\"ex_71-setup\"", eval = "TRUE", 
            echo = "FALSE", message = "FALSE", warning = "FALSE"), 
        engine = "r"), list(label = "ex71_2", code = "gl.report.basics(rfbe)", 
        opts = list(label = "\"ex71_2\"", exercise = "TRUE", 
            exercise.setup = "\"ex_71-setup\"", class.chunk = "\"gold-panel\""), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "session2_sim_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "session2_sim_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 7L, fig.height = 5L, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 672L, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        fig.asp = NULL, fenced.echo = FALSE, ft.shadow = FALSE, 
        exercise.eval = FALSE, label = "ex71_2", exercise = TRUE, 
        exercise.setup = "ex_71-setup", class.chunk = "gold-panel", 
        original.params.src = "r  ex71_2, exercise = TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        chunk.echo = FALSE, code = "gl.report.basics(rfbe)", 
        out.width.px = 672L, out.height.px = 480L, params.src = "r  ex71_2, exercise = TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        fig.num = 0, exercise.df_print = "default", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ex71_4-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ex71_4-code-editor`)), session)
output$`tutorial-exercise-ex71_4-output` <- renderUI({
  `tutorial-exercise-ex71_4-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ex71_4", global_setup = NULL, setup = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
    chunks = list(list(label = "ex_71-setup", code = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
        opts = list(label = "\"ex_71-setup\"", eval = "TRUE", 
            echo = "FALSE", message = "FALSE", warning = "FALSE"), 
        engine = "r"), list(label = "ex71_4", code = "### number of individuals in the source population\n\n### missing data in the genotypes of the source population\n", 
        opts = list(label = "\"ex71_4\"", exercise = "TRUE", 
            exercise.setup = "\"ex_71-setup\"", class.chunk = "\"gold-panel\""), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "session2_sim_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "session2_sim_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 7L, fig.height = 5L, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 672L, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        fig.asp = NULL, fenced.echo = FALSE, ft.shadow = FALSE, 
        exercise.eval = FALSE, label = "ex71_4", exercise = TRUE, 
        exercise.setup = "ex_71-setup", class.chunk = "gold-panel", 
        original.params.src = "r ex71_4, exercise = TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        chunk.echo = FALSE, code = c("### number of individuals in the source population", 
        "", "### missing data in the genotypes of the source population", 
        ""), out.width.px = 672L, out.height.px = 480L, params.src = "r ex71_4, exercise = TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        fig.num = 0, exercise.df_print = "default", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ex71_6-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ex71_6-code-editor`)), session)
output$`tutorial-exercise-ex71_6-output` <- renderUI({
  `tutorial-exercise-ex71_6-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ex71_6", global_setup = NULL, setup = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
    chunks = list(list(label = "ex_71-setup", code = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
        opts = list(label = "\"ex_71-setup\"", eval = "TRUE", 
            echo = "FALSE", message = "FALSE", warning = "FALSE"), 
        engine = "r"), list(label = "ex71_6", code = "#check if there are no missing data in the genotypes of source2\n\n", 
        opts = list(label = "\"ex71_6\"", exercise = "TRUE", 
            exercise.setup = "\"ex_71-setup\"", class.chunk = "\"gold-panel\""), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "session2_sim_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "session2_sim_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 7L, fig.height = 5L, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 672L, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        fig.asp = NULL, fenced.echo = FALSE, ft.shadow = FALSE, 
        exercise.eval = FALSE, label = "ex71_6", exercise = TRUE, 
        exercise.setup = "ex_71-setup", class.chunk = "gold-panel", 
        original.params.src = "r ex71_6, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        chunk.echo = FALSE, code = c("#check if there are no missing data in the genotypes of source2", 
        "", ""), out.width.px = 672L, out.height.px = 480L, params.src = "r ex71_6, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        fig.num = 0, exercise.df_print = "default", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ex71_8-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ex71_8-code-editor`)), session)
output$`tutorial-exercise-ex71_8-output` <- renderUI({
  `tutorial-exercise-ex71_8-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ex71_8", global_setup = NULL, setup = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
    chunks = list(list(label = "ex_71-setup", code = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
        opts = list(label = "\"ex_71-setup\"", eval = "TRUE", 
            echo = "FALSE", message = "FALSE", warning = "FALSE"), 
        engine = "r"), list(label = "ex71_8", code = "#check number of individuals and missing data in newpop\n", 
        opts = list(label = "\"ex71_8\"", exercise = "TRUE", 
            exercise.setup = "\"ex_71-setup\"", class.chunk = "\"gold-panel\""), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "session2_sim_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "session2_sim_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 7L, fig.height = 5L, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 672L, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        fig.asp = NULL, fenced.echo = FALSE, ft.shadow = FALSE, 
        exercise.eval = FALSE, label = "ex71_8", exercise = TRUE, 
        exercise.setup = "ex_71-setup", class.chunk = "gold-panel", 
        original.params.src = "r ex71_8, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        chunk.echo = FALSE, code = c("#check number of individuals and missing data in newpop", 
        ""), out.width.px = 672L, out.height.px = 480L, params.src = "r ex71_8, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        fig.num = 0, exercise.df_print = "default", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ex71_9-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ex71_9-code-editor`)), session)
output$`tutorial-exercise-ex71_9-output` <- renderUI({
  `tutorial-exercise-ex71_9-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ex71_9", global_setup = NULL, setup = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
    chunks = list(list(label = "ex_71-setup", code = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
        opts = list(label = "\"ex_71-setup\"", eval = "TRUE", 
            echo = "FALSE", message = "FALSE", warning = "FALSE"), 
        engine = "r"), list(label = "ex71_9", code = "#find a way to calculate the mean heterozygosity of the new population\n\n\n", 
        opts = list(label = "\"ex71_9\"", exercise = "TRUE", 
            exercise.setup = "\"ex_71-setup\"", class.chunk = "\"gold-panel\""), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "session2_sim_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "session2_sim_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 7L, fig.height = 5L, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 672L, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        fig.asp = NULL, fenced.echo = FALSE, ft.shadow = FALSE, 
        exercise.eval = FALSE, label = "ex71_9", exercise = TRUE, 
        exercise.setup = "ex_71-setup", class.chunk = "gold-panel", 
        original.params.src = "r ex71_9, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        chunk.echo = FALSE, code = c("#find a way to calculate the mean heterozygosity of the new population", 
        "", "", ""), out.width.px = 672L, out.height.px = 480L, 
        params.src = "r ex71_9, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        fig.num = 0, exercise.df_print = "default", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ex71_11-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ex71_11-code-editor`)), session)
output$`tutorial-exercise-ex71_11-output` <- renderUI({
  `tutorial-exercise-ex71_11-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ex71_11", global_setup = NULL, setup = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
    chunks = list(list(label = "ex_71-setup", code = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
        opts = list(label = "\"ex_71-setup\"", eval = "TRUE", 
            echo = "FALSE", message = "FALSE", warning = "FALSE"), 
        engine = "r"), list(label = "ex71_11", code = "\nrfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose=0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\nres<-NA\nres[1] <- mean(gl.He(newpop))\n\nfor (gen in 2:15)\n{\n  #ideal popluation = cloning snails\n  newpop <- gl.sim.ind(newpop, n=10)\n  #He of generation gen\n  res[gen] <- mean(gl.He(newpop))\n}\n\nplot(res, type=\"b\", xlab=\"Generation\", ylab=\"Expected heterozygosity\", \n     main=\"Simulation of expected heterozygosity over time\")\n", 
        opts = list(label = "\"ex71_11\"", exercise = "TRUE", 
            exercise.setup = "\"ex_71-setup\"", class.chunk = "\"gold-panel\""), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "session2_sim_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "session2_sim_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 7L, fig.height = 5L, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 672L, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        fig.asp = NULL, fenced.echo = FALSE, ft.shadow = FALSE, 
        exercise.eval = FALSE, label = "ex71_11", exercise = TRUE, 
        exercise.setup = "ex_71-setup", class.chunk = "gold-panel", 
        original.params.src = "r ex71_11, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        chunk.echo = FALSE, code = c("", "rfbe <- readRDS(\"./data/rfbe.rds\")", 
        "source <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose=0)", 
        "source2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)", 
        "set.seed(7)", "newpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)", 
        "res<-NA", "res[1] <- mean(gl.He(newpop))", "", "for (gen in 2:15)", 
        "{", "  #ideal popluation = cloning snails", "  newpop <- gl.sim.ind(newpop, n=10)", 
        "  #He of generation gen", "  res[gen] <- mean(gl.He(newpop))", 
        "}", "", "plot(res, type=\"b\", xlab=\"Generation\", ylab=\"Expected heterozygosity\", ", 
        "     main=\"Simulation of expected heterozygosity over time\")", 
        ""), out.width.px = 672L, out.height.px = 480L, params.src = "r ex71_11, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        fig.num = 0, exercise.df_print = "default", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ex71_13-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ex71_13-code-editor`)), session)
output$`tutorial-exercise-ex71_13-output` <- renderUI({
  `tutorial-exercise-ex71_13-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ex71_13", global_setup = NULL, setup = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
    chunks = list(list(label = "ex_71-setup", code = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
        opts = list(label = "\"ex_71-setup\"", eval = "TRUE", 
            echo = "FALSE", message = "FALSE", warning = "FALSE"), 
        engine = "r"), list(label = "ex71_13", code = "\n#test the function\nout <- simHe(source2, nInd = 30, ngens = 20)\nplot(out, type=\"b\", xlab=\"Generation\", ylab=\"Expected heterozygosity\",\n     main=\"Simulation of expected heterozygosity over time\")\n", 
        opts = list(label = "\"ex71_13\"", exercise.eval = "TRUE", 
            exercise = "TRUE", exercise.setup = "\"ex_71-setup\"", 
            class.chunk = "\"gold-panel\""), engine = "r")), 
    code_check = NULL, error_check = NULL, check = NULL, solution = NULL, 
    tests = NULL, options = list(eval = TRUE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "session2_sim_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "session2_sim_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 7L, fig.height = 5L, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 672L, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        fig.asp = NULL, fenced.echo = FALSE, ft.shadow = FALSE, 
        exercise.eval = TRUE, label = "ex71_13", exercise = TRUE, 
        exercise.setup = "ex_71-setup", class.chunk = "gold-panel", 
        original.params.src = "r ex71_13, exercise.eval=TRUE,exercise=TRUE,exercise.setup=\"ex_71-setup\",class.chunk=\"gold-panel\"", 
        chunk.echo = FALSE, code = c("", "#test the function", 
        "out <- simHe(source2, nInd = 30, ngens = 20)", "plot(out, type=\"b\", xlab=\"Generation\", ylab=\"Expected heterozygosity\",", 
        "     main=\"Simulation of expected heterozygosity over time\")", 
        ""), out.width.px = 672L, out.height.px = 480L, params.src = "r ex71_13, exercise.eval=TRUE,exercise=TRUE,exercise.setup=\"ex_71-setup\",class.chunk=\"gold-panel\"", 
        fig.alt = NULL, fig.num = 1, exercise.df_print = "default", 
        exercise.checker = "NULL"), engine = "r", version = "4"), class = c("r", 
"tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ex71_14-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ex71_14-code-editor`)), session)
output$`tutorial-exercise-ex71_14-output` <- renderUI({
  `tutorial-exercise-ex71_14-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ex71_14", global_setup = NULL, setup = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
    chunks = list(list(label = "ex_71-setup", code = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
        opts = list(label = "\"ex_71-setup\"", eval = "TRUE", 
            echo = "FALSE", message = "FALSE", warning = "FALSE"), 
        engine = "r"), list(label = "ex71_14", code = "\nlibrary(future.apply)\nplan(multisession, workers=3) # or plan(multicore) on Unix-like systems\nn_sims <- 9\nsim_results <- future_lapply(1:n_sims, function(i) {\n  simHe(source2, nInd = 30, ngens = 20)},  future.seed=TRUE)\n\n#create a plot\noutmat <- data.frame(do.call(cbind, sim_results))\nmatplot(outmat, type=\"b\", xlab=\"Generation\", ylab=\"Expected heterozygosity\",\n        main=\"Simulation of expected heterozygosity over time\", col=1:n_sims, pch=1:n_sims)\n", 
        opts = list(label = "\"ex71_14\"", exercise = "TRUE", 
            exercise.setup = "\"ex_71-setup\"", class.chunk = "\"gold-panel\"", 
            exercise.timelimit = "120"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = NULL, solution = NULL, tests = NULL, 
    options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "session2_sim_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "session2_sim_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 7L, fig.height = 5L, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 672L, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        fig.asp = NULL, fenced.echo = FALSE, ft.shadow = FALSE, 
        exercise.eval = FALSE, label = "ex71_14", exercise = TRUE, 
        exercise.setup = "ex_71-setup", class.chunk = "gold-panel", 
        exercise.timelimit = 120, original.params.src = "r ex71_14, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\", exercise.timelimit=120", 
        chunk.echo = FALSE, code = c("", "library(future.apply)", 
        "plan(multisession, workers=3) # or plan(multicore) on Unix-like systems", 
        "n_sims <- 9", "sim_results <- future_lapply(1:n_sims, function(i) {", 
        "  simHe(source2, nInd = 30, ngens = 20)},  future.seed=TRUE)", 
        "", "#create a plot", "outmat <- data.frame(do.call(cbind, sim_results))", 
        "matplot(outmat, type=\"b\", xlab=\"Generation\", ylab=\"Expected heterozygosity\",", 
        "        main=\"Simulation of expected heterozygosity over time\", col=1:n_sims, pch=1:n_sims)", 
        ""), out.width.px = 672L, out.height.px = 480L, params.src = "r ex71_14, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\", exercise.timelimit=120", 
        fig.num = 0, exercise.df_print = "default", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ex71_15-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ex71_15-code-editor`)), session)
output$`tutorial-exercise-ex71_15-output` <- renderUI({
  `tutorial-exercise-ex71_15-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ex71_15", global_setup = NULL, setup = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
    chunks = list(list(label = "ex_71-setup", code = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
        opts = list(label = "\"ex_71-setup\"", eval = "TRUE", 
            echo = "FALSE", message = "FALSE", warning = "FALSE"), 
        engine = "r"), list(label = "ex71_15", code = "", opts = list(
        label = "\"ex71_15\"", exercise = "TRUE", exercise.setup = "\"ex_71-setup\"", 
        class.chunk = "\"gold-panel\""), engine = "r")), code_check = NULL, 
    error_check = NULL, check = NULL, solution = NULL, tests = NULL, 
    options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "session2_sim_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "session2_sim_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 7L, fig.height = 5L, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 672L, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        fig.asp = NULL, fenced.echo = FALSE, ft.shadow = FALSE, 
        exercise.eval = FALSE, label = "ex71_15", exercise = TRUE, 
        exercise.setup = "ex_71-setup", class.chunk = "gold-panel", 
        original.params.src = "r ex71_15, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        chunk.echo = FALSE, code = "", out.width.px = 672L, out.height.px = 480L, 
        params.src = "r ex71_15, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        fig.num = 0L, exercise.df_print = "default", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ex72_2-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ex72_2-code-editor`)), session)
output$`tutorial-exercise-ex72_2-output` <- renderUI({
  `tutorial-exercise-ex72_2-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ex72_2", global_setup = NULL, setup = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
    chunks = list(list(label = "ex_71-setup", code = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
        opts = list(label = "\"ex_71-setup\"", eval = "TRUE", 
            echo = "FALSE", message = "FALSE", warning = "FALSE"), 
        engine = "r"), list(label = "ex72_2", code = "# EXERCISE:\n# 1) Change n to 50, 200 and compare the smearplots.\n# 2) What happens if you use fewer loci (e.g., 200 loci)?", 
        opts = list(label = "\"ex72_2\"", exercise = "TRUE", 
            exercise.setup = "\"ex_71-setup\"", class.chunk = "\"gold-panel\""), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "session2_sim_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "session2_sim_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 7L, fig.height = 5L, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 672L, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        fig.asp = NULL, fenced.echo = FALSE, ft.shadow = FALSE, 
        exercise.eval = FALSE, label = "ex72_2", exercise = TRUE, 
        exercise.setup = "ex_71-setup", class.chunk = "gold-panel", 
        original.params.src = "r ex72_2, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        chunk.echo = FALSE, code = c("# EXERCISE:", "# 1) Change n to 50, 200 and compare the smearplots.", 
        "# 2) What happens if you use fewer loci (e.g., 200 loci)?"
        ), out.width.px = 672L, out.height.px = 480L, params.src = "r ex72_2, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        fig.num = 0, exercise.df_print = "default", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ex72_4-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ex72_4-code-editor`)), session)
output$`tutorial-exercise-ex72_4-output` <- renderUI({
  `tutorial-exercise-ex72_4-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ex72_4", global_setup = NULL, setup = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
    chunks = list(list(label = "ex_71-setup", code = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
        opts = list(label = "\"ex_71-setup\"", eval = "TRUE", 
            echo = "FALSE", message = "FALSE", warning = "FALSE"), 
        engine = "r"), list(label = "ex72_4", code = "# DISCUSSION EXERCISE (no coding required):\n# When would you prefer gl.sim.ind() over gl.sim.Neconst() as a starting point?\n# (Think: allele frequencies, realism, availability of data.)", 
        opts = list(label = "\"ex72_4\"", exercise = "TRUE", 
            exercise.setup = "\"ex_71-setup\"", class.chunk = "\"gold-panel\""), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "session2_sim_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "session2_sim_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 7L, fig.height = 5L, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 672L, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        fig.asp = NULL, fenced.echo = FALSE, ft.shadow = FALSE, 
        exercise.eval = FALSE, label = "ex72_4", exercise = TRUE, 
        exercise.setup = "ex_71-setup", class.chunk = "gold-panel", 
        original.params.src = "r ex72_4, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        chunk.echo = FALSE, code = c("# DISCUSSION EXERCISE (no coding required):", 
        "# When would you prefer gl.sim.ind() over gl.sim.Neconst() as a starting point?", 
        "# (Think: allele frequencies, realism, availability of data.)"
        ), out.width.px = 672L, out.height.px = 480L, params.src = "r ex72_4, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        fig.num = 0, exercise.df_print = "default", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ex73_2-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ex73_2-code-editor`)), session)
output$`tutorial-exercise-ex73_2-output` <- renderUI({
  `tutorial-exercise-ex73_2-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ex73_2", global_setup = NULL, setup = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
    chunks = list(list(label = "ex_71-setup", code = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
        opts = list(label = "\"ex_71-setup\"", eval = "TRUE", 
            echo = "FALSE", message = "FALSE", warning = "FALSE"), 
        engine = "r"), list(label = "ex73_2", code = "g1 <- gl.sim.ind(source2[,1:1000], n = 10, popname = \"pop1\")\ng2 <- gl.sim.ind(source2[,1:1000], n = 10, popname = \"pop2\")\nfst_mig <- NA\nfor (i in 1:20) {\n  g1 <- gl.sim.ind(g1, n = 10, popname = \"pop1\")\n  g2 <- gl.sim.ind(g2, n = 10, popname = \"pop2\")\n  \n### migration (exchange of individuals between populations)\n  # for example one individuals both ways\n  # gg <- rbind(g1, g2)\n  # migtable <- matrix(c(0,1,1,0), nrow=2, ncol=2) \n  #  gg <- gl.sim.emigration(gg, emi.table=migtable)\n  #  g1 <- gg[pop=\"pop1\",]\n  #  g2 <- gg[pop=\"pop2\",]\n\n### calculate fst\n  gg <- rbind(g1, g2)\n  fst_mig[i] <- gl.fst.pop(gg, verbose = 0)[2, 1]\n}\nplot(fst_mig, type=\"b\", xlab=\"Generation\", ylab=\"Fst\", main=\"Fst over time\")\n", 
        opts = list(label = "\"ex73_2\"", exercise = "TRUE", 
            exercise.setup = "\"ex_71-setup\"", class.chunk = "\"gold-panel\"", 
            exercise.eval = "FALSE", exercise.lines = "26", exercise.timelimit = "120"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "session2_sim_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "session2_sim_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 7L, fig.height = 5L, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 672L, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        fig.asp = NULL, fenced.echo = FALSE, ft.shadow = FALSE, 
        exercise.eval = FALSE, label = "ex73_2", exercise = TRUE, 
        exercise.setup = "ex_71-setup", class.chunk = "gold-panel", 
        exercise.lines = 26, exercise.timelimit = 120, original.params.src = "r ex73_2, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\", exercise.eval=FALSE, exercise.lines=26, exercise.timelimit=120", 
        chunk.echo = FALSE, code = c("g1 <- gl.sim.ind(source2[,1:1000], n = 10, popname = \"pop1\")", 
        "g2 <- gl.sim.ind(source2[,1:1000], n = 10, popname = \"pop2\")", 
        "fst_mig <- NA", "for (i in 1:20) {", "  g1 <- gl.sim.ind(g1, n = 10, popname = \"pop1\")", 
        "  g2 <- gl.sim.ind(g2, n = 10, popname = \"pop2\")", 
        "  ", "### migration (exchange of individuals between populations)", 
        "  # for example one individuals both ways", "  # gg <- rbind(g1, g2)", 
        "  # migtable <- matrix(c(0,1,1,0), nrow=2, ncol=2) ", 
        "  #  gg <- gl.sim.emigration(gg, emi.table=migtable)", 
        "  #  g1 <- gg[pop=\"pop1\",]", "  #  g2 <- gg[pop=\"pop2\",]", 
        "", "### calculate fst", "  gg <- rbind(g1, g2)", "  fst_mig[i] <- gl.fst.pop(gg, verbose = 0)[2, 1]", 
        "}", "plot(fst_mig, type=\"b\", xlab=\"Generation\", ylab=\"Fst\", main=\"Fst over time\")", 
        ""), out.width.px = 672L, out.height.px = 480L, params.src = "r ex73_2, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\", exercise.eval=FALSE, exercise.lines=26, exercise.timelimit=120", 
        fig.num = 0, exercise.df_print = "default", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ex74_2-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ex74_2-code-editor`)), session)
output$`tutorial-exercise-ex74_2-output` <- renderUI({
  `tutorial-exercise-ex74_2-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ex74_2", global_setup = NULL, setup = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
    chunks = list(list(label = "ex_71-setup", code = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
        opts = list(label = "\"ex_71-setup\"", eval = "TRUE", 
            echo = "FALSE", message = "FALSE", warning = "FALSE"), 
        engine = "r"), list(label = "ex74_2", code = "start <- gl.filter.monomorphs(source2, verbose = 0)\nout <- sim_alleles_lost(start, ngens = 30, nind = 20, nloc = 1000, surv = 0.8, repro = 3, K = 100)\nout", 
        opts = list(label = "\"ex74_2\"", exercise = "TRUE", 
            exercise.eval = "TRUE", class.chunk = "\"gold-panel\"", 
            exercise.setup = "\"ex_71-setup\""), engine = "r")), 
    code_check = NULL, error_check = NULL, check = NULL, solution = NULL, 
    tests = NULL, options = list(eval = TRUE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "session2_sim_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "session2_sim_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 7L, fig.height = 5L, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 672L, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        fig.asp = NULL, fenced.echo = FALSE, ft.shadow = FALSE, 
        exercise.eval = TRUE, label = "ex74_2", exercise = TRUE, 
        class.chunk = "gold-panel", exercise.setup = "ex_71-setup", 
        original.params.src = "r ex74_2, exercise=TRUE, exercise.eval=TRUE, class.chunk=\"gold-panel\", exercise.setup=\"ex_71-setup\"", 
        chunk.echo = FALSE, code = c("start <- gl.filter.monomorphs(source2, verbose = 0)", 
        "out <- sim_alleles_lost(start, ngens = 30, nind = 20, nloc = 1000, surv = 0.8, repro = 3, K = 100)", 
        "out"), out.width.px = 672L, out.height.px = 480L, params.src = "r ex74_2, exercise=TRUE, exercise.eval=TRUE, class.chunk=\"gold-panel\", exercise.setup=\"ex_71-setup\"", 
        fig.alt = NULL, fig.num = 0, exercise.df_print = "default", 
        exercise.checker = "NULL"), engine = "r", version = "4"), class = c("r", 
"tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ex74_3-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ex74_3-code-editor`)), session)
output$`tutorial-exercise-ex74_3-output` <- renderUI({
  `tutorial-exercise-ex74_3-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ex74_3", global_setup = NULL, setup = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
    chunks = list(list(label = "ex_71-setup", code = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
        opts = list(label = "\"ex_71-setup\"", eval = "TRUE", 
            echo = "FALSE", message = "FALSE", warning = "FALSE"), 
        engine = "r"), list(label = "ex74_3", code = "# EXERCISE:\n# Run the same simulation, but change ONE parameter at a time.\n# Try:\n# 1) surv = 0.5 vs 0.9\n# 2) K = 50 vs 200\n# 3) nind = 20 vs 100\n#\n# Record (roughly) how alleles_lost changes and explain why.", 
        opts = list(label = "\"ex74_3\"", exercise = "TRUE", 
            exercise.setup = "\"ex_71-setup\"", class.chunk = "\"gold-panel\""), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "session2_sim_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "session2_sim_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 7L, fig.height = 5L, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 672L, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        fig.asp = NULL, fenced.echo = FALSE, ft.shadow = FALSE, 
        exercise.eval = FALSE, label = "ex74_3", exercise = TRUE, 
        exercise.setup = "ex_71-setup", class.chunk = "gold-panel", 
        original.params.src = "r ex74_3, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        chunk.echo = FALSE, code = c("# EXERCISE:", "# Run the same simulation, but change ONE parameter at a time.", 
        "# Try:", "# 1) surv = 0.5 vs 0.9", "# 2) K = 50 vs 200", 
        "# 3) nind = 20 vs 100", "#", "# Record (roughly) how alleles_lost changes and explain why."
        ), out.width.px = 672L, out.height.px = 480L, params.src = "r ex74_3, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        fig.num = 0, exercise.df_print = "default", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ex74_5-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ex74_5-code-editor`)), session)
output$`tutorial-exercise-ex74_5-output` <- renderUI({
  `tutorial-exercise-ex74_5-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ex74_5", global_setup = NULL, setup = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
    chunks = list(list(label = "ex_71-setup", code = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
        opts = list(label = "\"ex_71-setup\"", eval = "TRUE", 
            echo = "FALSE", message = "FALSE", warning = "FALSE"), 
        engine = "r"), list(label = "ex74_5", code = "# EXERCISE:\n# Modify the parameter grid to explore a different question.\n# For example:\n# - let ninds vary (e.g., 20, 50, 100)\n# - keep surv fixed, but vary K\n# - increase ngens to 30 (warning: slower)\n#\n# Then re-run and interpret the plot.", 
        opts = list(label = "\"ex74_5\"", exercise = "TRUE", 
            exercise.setup = "\"ex_71-setup\"", class.chunk = "\"gold-panel\""), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "session2_sim_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "session2_sim_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 7L, fig.height = 5L, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 672L, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        fig.asp = NULL, fenced.echo = FALSE, ft.shadow = FALSE, 
        exercise.eval = FALSE, label = "ex74_5", exercise = TRUE, 
        exercise.setup = "ex_71-setup", class.chunk = "gold-panel", 
        original.params.src = "r ex74_5, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        chunk.echo = FALSE, code = c("# EXERCISE:", "# Modify the parameter grid to explore a different question.", 
        "# For example:", "# - let ninds vary (e.g., 20, 50, 100)", 
        "# - keep surv fixed, but vary K", "# - increase ngens to 30 (warning: slower)", 
        "#", "# Then re-run and interpret the plot."), out.width.px = 672L, 
        out.height.px = 480L, params.src = "r ex74_5, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        fig.num = 0, exercise.df_print = "default", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ex75_2-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ex75_2-code-editor`)), session)
output$`tutorial-exercise-ex75_2-output` <- renderUI({
  `tutorial-exercise-ex75_2-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ex75_2", global_setup = NULL, setup = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
    chunks = list(list(label = "ex_71-setup", code = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
        opts = list(label = "\"ex_71-setup\"", eval = "TRUE", 
            echo = "FALSE", message = "FALSE", warning = "FALSE"), 
        engine = "r"), list(label = "ex75_2", code = "# EXERCISE:\n# Change panel size to nl = 25 and nl = 200.\n# Does r2_0 increase? What do you expect and why?", 
        opts = list(label = "\"ex75_2\"", exercise = "TRUE", 
            exercise.setup = "\"ex_71-setup\"", class.chunk = "\"gold-panel\""), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "session2_sim_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "session2_sim_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 7L, fig.height = 5L, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 672L, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        fig.asp = NULL, fenced.echo = FALSE, ft.shadow = FALSE, 
        exercise.eval = FALSE, label = "ex75_2", exercise = TRUE, 
        exercise.setup = "ex_71-setup", class.chunk = "gold-panel", 
        original.params.src = "r ex75_2, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        chunk.echo = FALSE, code = c("# EXERCISE:", "# Change panel size to nl = 25 and nl = 200.", 
        "# Does r2_0 increase? What do you expect and why?"), 
        out.width.px = 672L, out.height.px = 480L, params.src = "r ex75_2, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        fig.num = 0, exercise.df_print = "default", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ex75_4-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ex75_4-code-editor`)), session)
output$`tutorial-exercise-ex75_4-output` <- renderUI({
  `tutorial-exercise-ex75_4-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ex75_4", global_setup = NULL, setup = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
    chunks = list(list(label = "ex_71-setup", code = "rfbe <- readRDS(\"./data/rfbe.rds\")\nsource <- gl.keep.pop(rfbe, pop.list=\"PJTub1.2.3\", verbose = 0)\nsource2 <- gl.filter.callrate(source, method=\"loc\", threshold=1, verbose=0)\nset.seed(7)\nnewpop <- gl.subsample.ind(source2, n=10, replace = FALSE, verbose = 0)\n\nsimHe <- function(x, nInd=10, ngens=20)\n{\n  #remove all missing data\n\n  \n  #create a new genlight object based on allele frequencies from source2\n  transfer <- gl.subsample.ind(x, n=nInd, replace = FALSE, verbose = 0)\n  \n  res <- mean(gl.He(transfer))   #mean heterozygosity \n  \n  \n  for (gen in 2:ngens)\n  {\n    #cloning snails\n    transfer <- gl.sim.offspring(transfer, transfer, noffpermother = 1)\n    res[gen] <- mean(gl.He(transfer))\n    \n  }\n  \n  return(res)\n}\n\n\nsim_alleles_lost <- function(x, ngens = 30, nind = 100, nloc = 1000,\n                            surv = 0.8, repro = 3, K = 100) {\n  # create starting population\n  pop1 <- gl.sim.ind(x, n = nind, popname = \"pop1\")\n  pop1 <- pop1[, 1:nloc]\n\n  # allocate sex (stored in pop labels for convenience)\n  pop(pop1) <- sample(c(\"M\", \"F\"), nInd(pop1), replace = TRUE)\n\n  for (gen in 1:ngens) {\n    # offspring\n    off <- gl.sim.offspring(fathers = pop1[pop = \"M\"],\n                            mothers = pop1[pop = \"F\"],\n                            noffpermother = repro)\n    pop(off) <- sample(c(\"M\", \"F\"), nInd(off), replace = TRUE)\n\n    # survival of adults\n    keep <- rbinom(nInd(pop1), size = 1, prob = surv)\n    pop1 <- pop1[keep == 1, ]\n\n    # combine adults + offspring\n    pop1 <- rbind(pop1, off)\n\n    # enforce carrying capacity\n    if (nInd(pop1) > K) {\n      remove <- sample(1:nInd(pop1), nInd(pop1) - K, replace = FALSE)\n      pop1 <- pop1[-remove, ]\n    }\n  }\n\n  # count loci where an allele has been lost (very simple proxy)\n  # (works because genotypes are coded 0/1/2; allele lost -> mean is exactly 0 or 2)\n  alleles_lost <- sum(colMeans(as.matrix(pop1)) %% 2 == 0)\n  return(alleles_lost)\n}\n\n", 
        opts = list(label = "\"ex_71-setup\"", eval = "TRUE", 
            echo = "FALSE", message = "FALSE", warning = "FALSE"), 
        engine = "r"), list(label = "ex75_4", code = "# FINAL EXERCISE (playground):\n# Change ONE of the following and re-run:\n# 1) noffpermother = 1 vs 5  (drift strength changes)\n# 2) panel selection method (e.g., method=\"fst\" or another you used earlier)\n# 3) number of populations included (e.g., first 5 vs first 9)\n#\n# QUESTIONS:\n# - Does panel performance decay faster or slower?\n# - Why?", 
        opts = list(label = "\"ex75_4\"", exercise = "TRUE", 
            exercise.setup = "\"ex_71-setup\"", class.chunk = "\"gold-panel\""), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "session2_sim_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "session2_sim_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 7L, fig.height = 5L, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 672L, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        fig.asp = NULL, fenced.echo = FALSE, ft.shadow = FALSE, 
        exercise.eval = FALSE, label = "ex75_4", exercise = TRUE, 
        exercise.setup = "ex_71-setup", class.chunk = "gold-panel", 
        original.params.src = "r ex75_4, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        chunk.echo = FALSE, code = c("# FINAL EXERCISE (playground):", 
        "# Change ONE of the following and re-run:", "# 1) noffpermother = 1 vs 5  (drift strength changes)", 
        "# 2) panel selection method (e.g., method=\"fst\" or another you used earlier)", 
        "# 3) number of populations included (e.g., first 5 vs first 9)", 
        "#", "# QUESTIONS:", "# - Does panel performance decay faster or slower?", 
        "# - Why?"), out.width.px = 672L, out.height.px = 480L, 
        params.src = "r ex75_4, exercise=TRUE, exercise.setup=\"ex_71-setup\", class.chunk=\"gold-panel\"", 
        fig.num = 0, exercise.df_print = "default", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server-extras">
ojs_define <- function(..., .session = shiny::getDefaultReactiveDomain()) {
  quos <- rlang::enquos(...)
  vars <- rlang::list2(...)
  nm <- names(vars)
  if (is.null(nm)) {
    nm <- rep_len("", length(vars))
  }
  mapply(
    function(q, nm, val) {
      # Infer name, if possible
      if (nm == "") {
        tryCatch(
          {
            nm <- rlang::as_name(q)
          },
          error = function(e) {
            code <- paste(collapse = "\n", deparse(rlang::f_rhs(q)))
            stop(
              "ojs_define() could not create a name for the argument: ",
              code
            )
          }
        )
      }
      .session$output[[nm]] <- val
      outputOptions(.session$output, nm, suspendWhenHidden = FALSE)
      .session$sendCustomMessage("ojs-export", list(name = nm))
      NULL
    },
    quos,
    nm,
    vars,
    SIMPLIFY = FALSE,
    USE.NAMES = FALSE
  )
  invisible()
}
</script>
</p>
<!--html_preserve-->
<script type="application/shiny-prerendered" data-context="dependencies">
{"type":"list","attributes":{},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboard"]},{"type":"character","attributes":{},"value":["1.7.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file","href"]}},"value":[{"type":"character","attributes":{},"value":["htmldependencies/lib/clipboard-1.7.1"]},{"type":"character","attributes":{},"value":["https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["klippy"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.0.0.9500"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["primer-tooltips"]},{"type":"character","attributes":{},"value":["1.4.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file","href"]}},"value":[{"type":"character","attributes":{},"value":["htmldependencies/lib/primer-tooltips-1.4.0"]},{"type":"character","attributes":{},"value":["https://cdn.jsdelivr.net/npm/primer-tooltips@1.4.0/build/"]}]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["build.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["klippy"]},{"type":"logical","attributes":{},"value":[false]},{"type":"character","attributes":{},"value":["0.0.0.9500"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["klippy"]},{"type":"character","attributes":{},"value":["0.0.0.9500"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["htmldependencies/lib/klippy-0.0.0.9500"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/klippy.min.js"]},{"type":"character","attributes":{},"value":["css/klippy.min.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["klippy"]},{"type":"logical","attributes":{},"value":[false]},{"type":"character","attributes":{},"value":["0.0.0.9500"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.1.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["font-awesome"]},{"type":"character","attributes":{},"value":["6.5.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["fontawesome"]}]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["css/all.min.css","css/v4-shims.min.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["fontawesome"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.5.3"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootbox"]},{"type":"character","attributes":{},"value":["5.5.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/bootbox"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["bootbox.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["idb-keyvalue"]},{"type":"character","attributes":{},"value":["3.2.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/idb-keyval"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["idb-keyval-iife-compat.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[false]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial"]},{"type":"character","attributes":{},"value":["0.11.5"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial.js"]},{"type":"character","attributes":{},"value":["tutorial.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.5"]}]}]}
</script>
<!--/html_preserve-->
<!--html_preserve-->
<script type="application/shiny-prerendered" data-context="execution_dependencies">
{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages"]}},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages","version"]},"class":{"type":"character","attributes":{},"value":["data.frame"]},"row.names":{"type":"integer","attributes":{},"value":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174]}},"value":[{"type":"character","attributes":{},"value":["ade4","adegenet","ape","arsenal","assertthat","backports","base","base64enc","bigassertr","bigparallelr","bigsnpr","bigsparser","bigstatsr","BiocGenerics","bitops","cachem","checkmate","cli","cluster","codetools","colorspace","compiler","cowplot","crayon","dartR.base","dartR.captive","dartR.data","dartR.popgen","dartR.sexlinked","dartR.sim","dartR.spatial","dartRverse","data.table","datasets","devtools","dichromat","digest","dismo","doParallel","doRNG","dotCall64","dplyr","ellipsis","evaluate","fansi","farver","fastmap","fields","flock","fontawesome","foreach","foreign","Formula","fs","furrr","future","gdsfmt","generics","ggdendro","ggplot2","ggpmisc","ggpp","ggrepel","globals","glue","graphics","grDevices","grid","gridExtra","gtable","gtools","haplo.stats","Hmisc","htmlTable","htmltools","htmlwidgets","httpuv","httr","igraph","iterators","jquerylib","jsonlite","klippy","knitr","later","lattice","LEA","learnr","lifecycle","listenv","magrittr","maps","MASS","Matrix","MatrixModels","memoise","methods","mgcv","mime","miniUI","multcomp","mvtnorm","nlme","nnet","parallel","parallelly","patchwork","pegas","permute","pillar","pkgbuild","pkgconfig","pkgload","plyr","poisbinom","polspline","polynom","profvis","promises","purrr","quantreg","R6","raster","RColorBrewer","Rcpp","RCurl","related","remotes","reshape2","rlang","rmarkdown","rmio","rms","rngtools","rpart","rprojroot","rstudioapi","S7","sandwich","scales","seqinr","sessioninfo","shiny","SNPassoc","SNPRelate","snpStats","sp","spam","SparseM","splines","StAMPP","stats","stringi","stringr","survival","terra","TH.data","tibble","tidyr","tidyselect","tools","urlchecker","usethis","utf8","utils","vctrs","vegan","viridisLite","withr","xfun","xtable","yaml","zlibbioc","zoo"]},{"type":"character","attributes":{},"value":["1.7-22","2.1.10","5.8","3.6.3","0.2.1","1.5.0","4.4.1","0.1-3","0.1.7","0.3.2","1.12.18","0.7.3","1.6.2","0.52.0","1.0-9","1.1.0","2.3.2","3.6.3","2.1.6","0.2-20","2.1-1","4.4.1","1.1.3","1.5.3","1.1.2","1.0.34","1.0.9","1.0.6","1.0.5","0.95","1.0.1","1.0.5","1.16.2","4.4.1","2.4.5","2.0-0.1","0.6.37","1.3-14","1.0.17","1.8.6.2","1.2","1.1.4","0.3.2","1.0.1","1.0.6","2.1.2","1.2.0","16.3","0.7","0.5.3","1.5.2","0.8-87","1.2-5","1.6.5","0.3.1","1.34.0","1.42.0","0.1.3","0.2.0","4.0.0","0.6.1","0.5.8-1","0.9.6","0.16.3","1.7.0","4.4.1","4.4.1","4.4.1","2.3","0.3.6","3.9.5","1.9.7","5.2-0","2.4.3","0.5.8.1","1.6.4","1.6.15","1.4.7","2.1.1","1.0.14","0.1.4","1.8.9","0.0.0.9500","1.49","1.3.2","0.22-6","3.18.0","0.11.5","1.0.4","0.9.1","2.0.3","3.4.2.1","7.3-61","1.7-1","0.5-3","2.0.1","4.4.1","1.9-1","0.12","0.1.1.1","1.4-26","1.3-1","3.1-166","7.3-19","4.4.1","1.38.0","1.3.2","1.3","0.9-7","1.9.0","1.4.5","2.0.3","1.4.0","1.8.9","1.0.1","1.1.25","1.4-1","0.4.0","1.3.0","1.0.2","5.99","2.5.1","3.6-30","1.1-3","1.0.13","1.98-1.16","0.8","2.5.0","1.4.4","1.1.4","2.29","0.4.0","6.8-2","1.5.2","4.1.23","2.0.4","0.17.1","0.2.0","3.1-1","1.4.0","4.2-36","1.2.2","1.9.1","2.1-2","1.40.0","1.56.0","2.1-4","2.11-0","1.84-2","4.4.1","1.6.3","4.4.1","1.8.4","1.5.1","3.7-0","1.7-83","1.1-2","3.2.1","1.3.1","1.2.1","4.4.1","1.0.1","3.1.0","1.2.4","4.4.1","0.6.5","2.6-8","0.4.2","3.0.2","0.49","1.8-4","2.3.10","1.52.0","1.8-12"]}]}]}
</script>
<!--/html_preserve-->


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
            // default icon
            link.classList.add("external");
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../../inst/tutorials/session1/session1.html" class="pagination-link" aria-label="EpisodeII: Attack of the Clades">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">EpisodeII: Attack of the Clades</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->




</body></html>